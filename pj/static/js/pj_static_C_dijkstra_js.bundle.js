/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkmapapp"] = self["webpackChunkmapapp"] || []).push([["pj_static_C_dijkstra_js"],{

/***/ "./pj/static/C++/dijkstra.js":
/*!***********************************!*\
  !*** ./pj/static/C++/dijkstra.js ***!
  \***********************************/
/***/ ((module, exports, __webpack_require__) => {

eval("/* module decorator */ module = __webpack_require__.nmd(module);\nvar __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _toConsumableArray(r) { return _arrayWithoutHoles(r) || _iterableToArray(r) || _unsupportedIterableToArray(r) || _nonIterableSpread(); }\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _iterableToArray(r) { if (\"undefined\" != typeof Symbol && null != r[Symbol.iterator] || null != r[\"@@iterator\"]) return Array.from(r); }\nfunction _arrayWithoutHoles(r) { if (Array.isArray(r)) return _arrayLikeToArray(r); }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _classCallCheck(a, n) { if (!(a instanceof n)) throw new TypeError(\"Cannot call a class as a function\"); }\nfunction _defineProperties(e, r) { for (var t = 0; t < r.length; t++) { var o = r[t]; o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, _toPropertyKey(o.key), o); } }\nfunction _createClass(e, r, t) { return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, \"prototype\", { writable: !1 }), e; }\nfunction _toPropertyKey(t) { var i = _toPrimitive(t, \"string\"); return \"symbol\" == _typeof(i) ? i : i + \"\"; }\nfunction _toPrimitive(t, r) { if (\"object\" != _typeof(t) || !t) return t; var e = t[Symbol.toPrimitive]; if (void 0 !== e) { var i = e.call(t, r || \"default\"); if (\"object\" != _typeof(i)) return i; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (\"string\" === r ? String : Number)(t); }\nvar Module = function (_document$currentScri) {\n  var _scriptName = typeof document != 'undefined' ? (_document$currentScri = document.currentScript) === null || _document$currentScri === void 0 ? void 0 : _document$currentScri.src : undefined;\n  return function () {\n    var moduleArg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var moduleRtn;\n\n    // include: shell.js\n    // The Module object: Our interface to the outside world. We import\n    // and export values on it. There are various ways Module can be used:\n    // 1. Not defined. We create it here\n    // 2. A function parameter, function(moduleArg) => Promise<Module>\n    // 3. pre-run appended it, var Module = {}; ..generated code..\n    // 4. External script tag defines var Module.\n    // We need to check if Module already exists (e.g. case 3 above).\n    // Substitution will be replaced with actual code on later stage of the build,\n    // this way Closure Compiler will not mangle it (e.g. case 4. above).\n    // Note that if you want to run closure, and also to use Module\n    // after the generated code, you will need to define   var Module = {};\n    // before the code. Then that object will be used in the code, and you\n    // can continue to use Module afterwards as well.\n    var Module = moduleArg;\n\n    // Set up the promise that indicates the Module is initialized\n    var readyPromiseResolve, readyPromiseReject;\n    var readyPromise = new Promise(function (resolve, reject) {\n      readyPromiseResolve = resolve;\n      readyPromiseReject = reject;\n    });\n\n    // Determine the runtime environment we are in. You can customize this by\n    // setting the ENVIRONMENT setting at compile time (see settings.js).\n\n    var ENVIRONMENT_IS_WEB = true;\n    var ENVIRONMENT_IS_WORKER = false;\n    var ENVIRONMENT_IS_NODE = false;\n    var ENVIRONMENT_IS_SHELL = false;\n\n    // --pre-jses are emitted after the Module integration code, so that they can\n    // refer to Module (if they choose; they can also define Module)\n\n    // Sometimes an existing Module object exists with properties\n    // meant to overwrite the default module functionality. Here\n    // we collect those properties and reapply _after_ we configure\n    // the current environment's defaults to avoid having to be so\n    // defensive during initialization.\n    var moduleOverrides = Object.assign({}, Module);\n    var arguments_ = [];\n    var thisProgram = './this.program';\n    var quit_ = function quit_(status, toThrow) {\n      throw toThrow;\n    };\n\n    // `/` should be present at the end if `scriptDirectory` is not empty\n    var scriptDirectory = '';\n    function locateFile(path) {\n      if (Module['locateFile']) {\n        return Module['locateFile'](path, scriptDirectory);\n      }\n      return scriptDirectory + path;\n    }\n\n    // Hooks that are implemented differently in different runtime environments.\n    var readAsync, readBinary;\n\n    // Note that this includes Node.js workers when relevant (pthreads is enabled).\n    // Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\n    // ENVIRONMENT_IS_NODE.\n    if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n      if (ENVIRONMENT_IS_WORKER) {\n        // Check worker, not web, since window could be polyfilled\n        scriptDirectory = self.location.href;\n      } else if (typeof document != 'undefined' && document.currentScript) {\n        // web\n        scriptDirectory = document.currentScript.src;\n      }\n      // When MODULARIZE, this JS may be executed later, after document.currentScript\n      // is gone, so we saved it, and we use it here instead of any other info.\n      if (_scriptName) {\n        scriptDirectory = _scriptName;\n      }\n      // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\n      // otherwise, slice off the final part of the url to find the script directory.\n      // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\n      // and scriptDirectory will correctly be replaced with an empty string.\n      // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),\n      // they are removed because they could contain a slash.\n      if (scriptDirectory.startsWith('blob:')) {\n        scriptDirectory = '';\n      } else {\n        scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/') + 1);\n      }\n      {\n        // include: web_or_worker_shell_read.js\n        readAsync = function readAsync(url) {\n          return fetch(url, {\n            credentials: 'same-origin'\n          }).then(function (response) {\n            if (response.ok) {\n              return response.arrayBuffer();\n            }\n            return Promise.reject(new Error(response.status + ' : ' + response.url));\n          });\n        };\n        // end include: web_or_worker_shell_read.js\n      }\n    } else {}\n    var out = Module['print'] || console.log.bind(console);\n    var err = Module['printErr'] || console.error.bind(console);\n\n    // Merge back in the overrides\n    Object.assign(Module, moduleOverrides);\n    // Free the object hierarchy contained in the overrides, this lets the GC\n    // reclaim data used.\n    moduleOverrides = null;\n\n    // Emit code to handle expected values on the Module object. This applies Module.x\n    // to the proper local x. This has two benefits: first, we only emit it if it is\n    // expected to arrive, and second, by using a local everywhere else that can be\n    // minified.\n\n    if (Module['arguments']) arguments_ = Module['arguments'];\n    if (Module['thisProgram']) thisProgram = Module['thisProgram'];\n    if (Module['quit']) quit_ = Module['quit'];\n\n    // perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\n    // end include: shell.js\n\n    // include: preamble.js\n    // === Preamble library stuff ===\n\n    // Documentation for the public APIs defined in this file must be updated in:\n    //    site/source/docs/api_reference/preamble.js.rst\n    // A prebuilt local version of the documentation is available at:\n    //    site/build/text/docs/api_reference/preamble.js.txt\n    // You can also build docs locally as HTML or other formats in site/\n    // An online HTML version (which may be of a different version of Emscripten)\n    //    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n\n    var wasmBinary;\n    if (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];\n\n    // Wasm globals\n\n    var wasmMemory;\n\n    //========================================\n    // Runtime essentials\n    //========================================\n\n    // whether we are quitting the application. no code should run after this.\n    // set in exit() and abort()\n    var ABORT = false;\n\n    // set by exit() and abort().  Passed to 'onExit' handler.\n    // NOTE: This is also used as the process return code code in shell environments\n    // but only when noExitRuntime is false.\n    var EXITSTATUS;\n\n    // In STRICT mode, we only define assert() when ASSERTIONS is set.  i.e. we\n    // don't define it at all in release modes.  This matches the behaviour of\n    // MINIMAL_RUNTIME.\n    // TODO(sbc): Make this the default even without STRICT enabled.\n    /** @type {function(*, string=)} */\n    function assert(condition, text) {\n      if (!condition) {\n        // This build was created without ASSERTIONS defined.  `assert()` should not\n        // ever be called in this configuration but in case there are callers in\n        // the wild leave this simple abort() implementation here for now.\n        abort(text);\n      }\n    }\n\n    // Memory management\n\n    var HEAP, /** @type {!Int8Array} */\n      HEAP8, /** @type {!Uint8Array} */\n      HEAPU8, /** @type {!Int16Array} */\n      HEAP16, /** @type {!Uint16Array} */\n      HEAPU16, /** @type {!Int32Array} */\n      HEAP32, /** @type {!Uint32Array} */\n      HEAPU32, /** @type {!Float32Array} */\n      HEAPF32, /** @type {!Float64Array} */\n      HEAPF64;\n\n    // include: runtime_shared.js\n    function updateMemoryViews() {\n      var b = wasmMemory.buffer;\n      Module['HEAP8'] = HEAP8 = new Int8Array(b);\n      Module['HEAP16'] = HEAP16 = new Int16Array(b);\n      Module['HEAPU8'] = HEAPU8 = new Uint8Array(b);\n      Module['HEAPU16'] = HEAPU16 = new Uint16Array(b);\n      Module['HEAP32'] = HEAP32 = new Int32Array(b);\n      Module['HEAPU32'] = HEAPU32 = new Uint32Array(b);\n      Module['HEAPF32'] = HEAPF32 = new Float32Array(b);\n      Module['HEAPF64'] = HEAPF64 = new Float64Array(b);\n    }\n    // end include: runtime_shared.js\n    // include: runtime_stack_check.js\n    // end include: runtime_stack_check.js\n    // include: runtime_assertions.js\n    // end include: runtime_assertions.js\n    var __ATPRERUN__ = []; // functions called before the runtime is initialized\n    var __ATINIT__ = []; // functions called during startup\n    var __ATEXIT__ = []; // functions called during shutdown\n    var __ATPOSTRUN__ = []; // functions called after the main() is called\n\n    var runtimeInitialized = false;\n    function preRun() {\n      if (Module['preRun']) {\n        if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\n        while (Module['preRun'].length) {\n          addOnPreRun(Module['preRun'].shift());\n        }\n      }\n      callRuntimeCallbacks(__ATPRERUN__);\n    }\n    function initRuntime() {\n      runtimeInitialized = true;\n      if (!Module['noFSInit'] && !FS.init.initialized) FS.init();\n      FS.ignorePermissions = false;\n      TTY.init();\n      callRuntimeCallbacks(__ATINIT__);\n    }\n    function postRun() {\n      if (Module['postRun']) {\n        if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\n        while (Module['postRun'].length) {\n          addOnPostRun(Module['postRun'].shift());\n        }\n      }\n      callRuntimeCallbacks(__ATPOSTRUN__);\n    }\n    function addOnPreRun(cb) {\n      __ATPRERUN__.unshift(cb);\n    }\n    function addOnInit(cb) {\n      __ATINIT__.unshift(cb);\n    }\n    function addOnExit(cb) {}\n    function addOnPostRun(cb) {\n      __ATPOSTRUN__.unshift(cb);\n    }\n\n    // include: runtime_math.js\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\n\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround\n\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc\n\n    // end include: runtime_math.js\n    // A counter of dependencies for calling run(). If we need to\n    // do asynchronous work before running, increment this and\n    // decrement it. Incrementing must happen in a place like\n    // Module.preRun (used by emcc to add file preloading).\n    // Note that you can add dependencies in preRun, even though\n    // it happens right before run - run will be postponed until\n    // the dependencies are met.\n    var runDependencies = 0;\n    var runDependencyWatcher = null;\n    var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\n\n    function getUniqueRunDependency(id) {\n      return id;\n    }\n    function addRunDependency(id) {\n      var _Module$monitorRunDep;\n      runDependencies++;\n      (_Module$monitorRunDep = Module['monitorRunDependencies']) === null || _Module$monitorRunDep === void 0 || _Module$monitorRunDep.call(Module, runDependencies);\n    }\n    function removeRunDependency(id) {\n      var _Module$monitorRunDep2;\n      runDependencies--;\n      (_Module$monitorRunDep2 = Module['monitorRunDependencies']) === null || _Module$monitorRunDep2 === void 0 || _Module$monitorRunDep2.call(Module, runDependencies);\n      if (runDependencies == 0) {\n        if (runDependencyWatcher !== null) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n        }\n        if (dependenciesFulfilled) {\n          var callback = dependenciesFulfilled;\n          dependenciesFulfilled = null;\n          callback(); // can add another dependenciesFulfilled\n        }\n      }\n    }\n\n    /** @param {string|number=} what */\n    function abort(what) {\n      var _Module$onAbort;\n      (_Module$onAbort = Module['onAbort']) === null || _Module$onAbort === void 0 || _Module$onAbort.call(Module, what);\n      what = 'Aborted(' + what + ')';\n      // TODO(sbc): Should we remove printing and leave it up to whoever\n      // catches the exception?\n      err(what);\n      ABORT = true;\n      EXITSTATUS = 1;\n      what += '. Build with -sASSERTIONS for more info.';\n\n      // Use a wasm runtime error, because a JS error might be seen as a foreign\n      // exception, which means we'd run destructors on it. We need the error to\n      // simply make the program stop.\n      // FIXME This approach does not work in Wasm EH because it currently does not assume\n      // all RuntimeErrors are from traps; it decides whether a RuntimeError is from\n      // a trap or not based on a hidden field within the object. So at the moment\n      // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that\n      // allows this in the wasm spec.\n\n      // Suppress closure compiler warning here. Closure compiler's builtin extern\n      // definition for WebAssembly.RuntimeError claims it takes no arguments even\n      // though it can.\n      // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.\n      /** @suppress {checkTypes} */\n      var e = new WebAssembly.RuntimeError(what);\n      readyPromiseReject(e);\n      // Throw the error whether or not MODULARIZE is set because abort is used\n      // in code paths apart from instantiation where an exception is expected\n      // to be thrown when abort is called.\n      throw e;\n    }\n\n    // include: memoryprofiler.js\n    // end include: memoryprofiler.js\n    // include: URIUtils.js\n    // Prefix of data URIs emitted by SINGLE_FILE and related options.\n    var dataURIPrefix = 'data:application/octet-stream;base64,';\n\n    /**\n     * Indicates whether filename is a base64 data URI.\n     * @noinline\n     */\n    var isDataURI = function isDataURI(filename) {\n      return filename.startsWith(dataURIPrefix);\n    };\n\n    /**\n     * Indicates whether filename is delivered via file protocol (as opposed to http/https)\n     * @noinline\n     */\n    var isFileURI = function isFileURI(filename) {\n      return filename.startsWith('file://');\n    };\n    // end include: URIUtils.js\n    // include: runtime_exceptions.js\n    // end include: runtime_exceptions.js\n    function findWasmBinary() {\n      var f = 'dijkstra.wasm';\n      if (!isDataURI(f)) {\n        return locateFile(f);\n      }\n      return f;\n    }\n    var wasmBinaryFile;\n    function getBinarySync(file) {\n      if (file == wasmBinaryFile && wasmBinary) {\n        return new Uint8Array(wasmBinary);\n      }\n      if (readBinary) {\n        return readBinary(file);\n      }\n      throw 'both async and sync fetching of the wasm failed';\n    }\n    function getBinaryPromise(binaryFile) {\n      // If we don't have the binary yet, load it asynchronously using readAsync.\n      if (!wasmBinary) {\n        // Fetch the binary using readAsync\n        return readAsync(binaryFile).then(function (response) {\n          return new Uint8Array( /** @type{!ArrayBuffer} */response);\n        },\n        // Fall back to getBinarySync if readAsync fails\n        function () {\n          return getBinarySync(binaryFile);\n        });\n      }\n\n      // Otherwise, getBinarySync should be able to get it synchronously\n      return Promise.resolve().then(function () {\n        return getBinarySync(binaryFile);\n      });\n    }\n    function instantiateArrayBuffer(binaryFile, imports, receiver) {\n      return getBinaryPromise(binaryFile).then(function (binary) {\n        return WebAssembly.instantiate(binary, imports);\n      }).then(receiver, function (reason) {\n        err(\"failed to asynchronously prepare wasm: \".concat(reason));\n        abort(reason);\n      });\n    }\n    function instantiateAsync(binary, binaryFile, imports, callback) {\n      if (!binary && typeof WebAssembly.instantiateStreaming == 'function' && !isDataURI(binaryFile) && typeof fetch == 'function') {\n        return fetch(binaryFile, {\n          credentials: 'same-origin'\n        }).then(function (response) {\n          // Suppress closure warning here since the upstream definition for\n          // instantiateStreaming only allows Promise<Repsponse> rather than\n          // an actual Response.\n          // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.\n          /** @suppress {checkTypes} */\n          var result = WebAssembly.instantiateStreaming(response, imports);\n          return result.then(callback, function (reason) {\n            // We expect the most common failure cause to be a bad MIME type for the binary,\n            // in which case falling back to ArrayBuffer instantiation should work.\n            err(\"wasm streaming compile failed: \".concat(reason));\n            err('falling back to ArrayBuffer instantiation');\n            return instantiateArrayBuffer(binaryFile, imports, callback);\n          });\n        });\n      }\n      return instantiateArrayBuffer(binaryFile, imports, callback);\n    }\n    function getWasmImports() {\n      // prepare imports\n      return {\n        'env': wasmImports,\n        'wasi_snapshot_preview1': wasmImports\n      };\n    }\n\n    // Create the wasm instance.\n    // Receives the wasm imports, returns the exports.\n    function createWasm() {\n      var info = getWasmImports();\n      // Load the wasm module and create an instance of using native support in the JS engine.\n      // handle a generated wasm instance, receiving its exports and\n      // performing other necessary setup\n      /** @param {WebAssembly.Module=} module*/\n      function receiveInstance(instance, module) {\n        wasmExports = instance.exports;\n        wasmMemory = wasmExports['memory'];\n        updateMemoryViews();\n        addOnInit(wasmExports['__wasm_call_ctors']);\n        removeRunDependency('wasm-instantiate');\n        return wasmExports;\n      }\n      // wait for the pthread pool (if any)\n      addRunDependency('wasm-instantiate');\n\n      // Prefer streaming instantiation if available.\n      function receiveInstantiationResult(result) {\n        // 'result' is a ResultObject object which has both the module and instance.\n        // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n        // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\n        // When the regression is fixed, can restore the above PTHREADS-enabled path.\n        receiveInstance(result['instance']);\n      }\n\n      // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n      // to manually instantiate the Wasm module themselves. This allows pages to\n      // run the instantiation parallel to any other async startup actions they are\n      // performing.\n      // Also pthreads and wasm workers initialize the wasm instance through this\n      // path.\n      if (Module['instantiateWasm']) {\n        try {\n          return Module['instantiateWasm'](info, receiveInstance);\n        } catch (e) {\n          err(\"Module.instantiateWasm callback failed with error: \".concat(e));\n          // If instantiation fails, reject the module ready promise.\n          readyPromiseReject(e);\n        }\n      }\n      if (!wasmBinaryFile) wasmBinaryFile = findWasmBinary();\n\n      // If instantiation fails, reject the module ready promise.\n      instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult)[\"catch\"](readyPromiseReject);\n      return {}; // no exports yet; we'll fill them in later\n    }\n\n    // Globals used by JS i64 conversions (see makeSetValue)\n    var tempDouble;\n    var tempI64;\n\n    // include: runtime_debug.js\n    // end include: runtime_debug.js\n    // === Body ===\n    // end include: preamble.js\n\n    /** @constructor */\n    function ExitStatus(status) {\n      this.name = 'ExitStatus';\n      this.message = \"Program terminated with exit(\".concat(status, \")\");\n      this.status = status;\n    }\n    var callRuntimeCallbacks = function callRuntimeCallbacks(callbacks) {\n      while (callbacks.length > 0) {\n        // Pass the module as the first argument.\n        callbacks.shift()(Module);\n      }\n    };\n\n    /**\n     * @param {number} ptr\n     * @param {string} type\n     */\n    function getValue(ptr) {\n      var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'i8';\n      if (type.endsWith('*')) type = '*';\n      switch (type) {\n        case 'i1':\n          return HEAP8[ptr];\n        case 'i8':\n          return HEAP8[ptr];\n        case 'i16':\n          return HEAP16[ptr >> 1];\n        case 'i32':\n          return HEAP32[ptr >> 2];\n        case 'i64':\n          abort('to do getValue(i64) use WASM_BIGINT');\n        case 'float':\n          return HEAPF32[ptr >> 2];\n        case 'double':\n          return HEAPF64[ptr >> 3];\n        case '*':\n          return HEAPU32[ptr >> 2];\n        default:\n          abort(\"invalid type for getValue: \".concat(type));\n      }\n    }\n    var noExitRuntime = Module['noExitRuntime'] || true;\n\n    /**\n     * @param {number} ptr\n     * @param {number} value\n     * @param {string} type\n     */\n    function setValue(ptr, value) {\n      var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'i8';\n      if (type.endsWith('*')) type = '*';\n      switch (type) {\n        case 'i1':\n          HEAP8[ptr] = value;\n          break;\n        case 'i8':\n          HEAP8[ptr] = value;\n          break;\n        case 'i16':\n          HEAP16[ptr >> 1] = value;\n          break;\n        case 'i32':\n          HEAP32[ptr >> 2] = value;\n          break;\n        case 'i64':\n          abort('to do setValue(i64) use WASM_BIGINT');\n        case 'float':\n          HEAPF32[ptr >> 2] = value;\n          break;\n        case 'double':\n          HEAPF64[ptr >> 3] = value;\n          break;\n        case '*':\n          HEAPU32[ptr >> 2] = value;\n          break;\n        default:\n          abort(\"invalid type for setValue: \".concat(type));\n      }\n    }\n    var stackRestore = function stackRestore(val) {\n      return _emscripten_stack_restore(val);\n    };\n    var stackSave = function stackSave() {\n      return _emscripten_stack_get_current2();\n    };\n    var ExceptionInfo = /*#__PURE__*/function () {\n      // excPtr - Thrown object pointer to wrap. Metadata pointer is calculated from it.\n      function ExceptionInfo(excPtr) {\n        _classCallCheck(this, ExceptionInfo);\n        this.excPtr = excPtr;\n        this.ptr = excPtr - 24;\n      }\n      return _createClass(ExceptionInfo, [{\n        key: \"set_type\",\n        value: function set_type(type) {\n          HEAPU32[this.ptr + 4 >> 2] = type;\n        }\n      }, {\n        key: \"get_type\",\n        value: function get_type() {\n          return HEAPU32[this.ptr + 4 >> 2];\n        }\n      }, {\n        key: \"set_destructor\",\n        value: function set_destructor(destructor) {\n          HEAPU32[this.ptr + 8 >> 2] = destructor;\n        }\n      }, {\n        key: \"get_destructor\",\n        value: function get_destructor() {\n          return HEAPU32[this.ptr + 8 >> 2];\n        }\n      }, {\n        key: \"set_caught\",\n        value: function set_caught(caught) {\n          caught = caught ? 1 : 0;\n          HEAP8[this.ptr + 12] = caught;\n        }\n      }, {\n        key: \"get_caught\",\n        value: function get_caught() {\n          return HEAP8[this.ptr + 12] != 0;\n        }\n      }, {\n        key: \"set_rethrown\",\n        value: function set_rethrown(rethrown) {\n          rethrown = rethrown ? 1 : 0;\n          HEAP8[this.ptr + 13] = rethrown;\n        }\n      }, {\n        key: \"get_rethrown\",\n        value: function get_rethrown() {\n          return HEAP8[this.ptr + 13] != 0;\n        }\n\n        // Initialize native structure fields. Should be called once after allocated.\n      }, {\n        key: \"init\",\n        value: function init(type, destructor) {\n          this.set_adjusted_ptr(0);\n          this.set_type(type);\n          this.set_destructor(destructor);\n        }\n      }, {\n        key: \"set_adjusted_ptr\",\n        value: function set_adjusted_ptr(adjustedPtr) {\n          HEAPU32[this.ptr + 16 >> 2] = adjustedPtr;\n        }\n      }, {\n        key: \"get_adjusted_ptr\",\n        value: function get_adjusted_ptr() {\n          return HEAPU32[this.ptr + 16 >> 2];\n        }\n\n        // Get pointer which is expected to be received by catch clause in C++ code. It may be adjusted\n        // when the pointer is casted to some of the exception object base classes (e.g. when virtual\n        // inheritance is used). When a pointer is thrown this method should return the thrown pointer\n        // itself.\n      }, {\n        key: \"get_exception_ptr\",\n        value: function get_exception_ptr() {\n          // Work around a fastcomp bug, this code is still included for some reason in a build without\n          // exceptions support.\n          var isPointer = _cxa_is_pointer_type(this.get_type());\n          if (isPointer) {\n            return HEAPU32[this.excPtr >> 2];\n          }\n          var adjusted = this.get_adjusted_ptr();\n          if (adjusted !== 0) return adjusted;\n          return this.excPtr;\n        }\n      }]);\n    }();\n    var exceptionLast = 0;\n    var uncaughtExceptionCount = 0;\n    var ___cxa_throw = function ___cxa_throw(ptr, type, destructor) {\n      var info = new ExceptionInfo(ptr);\n      // Initialize ExceptionInfo content after it was allocated in __cxa_allocate_exception.\n      info.init(type, destructor);\n      exceptionLast = ptr;\n      uncaughtExceptionCount++;\n      throw exceptionLast;\n    };\n\n    /** @suppress {duplicate } */\n    function syscallGetVarargI() {\n      // the `+` prepended here is necessary to convince the JSCompiler that varargs is indeed a number.\n      var ret = HEAP32[+SYSCALLS.varargs >> 2];\n      SYSCALLS.varargs += 4;\n      return ret;\n    }\n    var syscallGetVarargP = syscallGetVarargI;\n    var PATH = {\n      isAbs: function isAbs(path) {\n        return path.charAt(0) === '/';\n      },\n      splitPath: function splitPath(filename) {\n        var splitPathRe = /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n        return splitPathRe.exec(filename).slice(1);\n      },\n      normalizeArray: function normalizeArray(parts, allowAboveRoot) {\n        // if the path tries to go above the root, `up` ends up > 0\n        var up = 0;\n        for (var i = parts.length - 1; i >= 0; i--) {\n          var last = parts[i];\n          if (last === '.') {\n            parts.splice(i, 1);\n          } else if (last === '..') {\n            parts.splice(i, 1);\n            up++;\n          } else if (up) {\n            parts.splice(i, 1);\n            up--;\n          }\n        }\n        // if the path is allowed to go above the root, restore leading ..s\n        if (allowAboveRoot) {\n          for (; up; up--) {\n            parts.unshift('..');\n          }\n        }\n        return parts;\n      },\n      normalize: function normalize(path) {\n        var isAbsolute = PATH.isAbs(path),\n          trailingSlash = path.substr(-1) === '/';\n        // Normalize the path\n        path = PATH.normalizeArray(path.split('/').filter(function (p) {\n          return !!p;\n        }), !isAbsolute).join('/');\n        if (!path && !isAbsolute) {\n          path = '.';\n        }\n        if (path && trailingSlash) {\n          path += '/';\n        }\n        return (isAbsolute ? '/' : '') + path;\n      },\n      dirname: function dirname(path) {\n        var result = PATH.splitPath(path),\n          root = result[0],\n          dir = result[1];\n        if (!root && !dir) {\n          // No dirname whatsoever\n          return '.';\n        }\n        if (dir) {\n          // It has a dirname, strip trailing slash\n          dir = dir.substr(0, dir.length - 1);\n        }\n        return root + dir;\n      },\n      basename: function basename(path) {\n        // EMSCRIPTEN return '/'' for '/', not an empty string\n        if (path === '/') return '/';\n        path = PATH.normalize(path);\n        path = path.replace(/\\/$/, \"\");\n        var lastSlash = path.lastIndexOf('/');\n        if (lastSlash === -1) return path;\n        return path.substr(lastSlash + 1);\n      },\n      join: function join() {\n        for (var _len = arguments.length, paths = new Array(_len), _key = 0; _key < _len; _key++) {\n          paths[_key] = arguments[_key];\n        }\n        return PATH.normalize(paths.join('/'));\n      },\n      join2: function join2(l, r) {\n        return PATH.normalize(l + '/' + r);\n      }\n    };\n    var initRandomFill = function initRandomFill() {\n      if ((typeof crypto === \"undefined\" ? \"undefined\" : _typeof(crypto)) == 'object' && typeof crypto['getRandomValues'] == 'function') {\n        // for modern web browsers\n        return function (view) {\n          return crypto.getRandomValues(view);\n        };\n      } else\n        // we couldn't find a proper implementation, as Math.random() is not suitable for /dev/random, see emscripten-core/emscripten/pull/7096\n        abort('initRandomDevice');\n    };\n    var _randomFill = function randomFill(view) {\n      // Lazily init on the first invocation.\n      return (_randomFill = initRandomFill())(view);\n    };\n    var PATH_FS = {\n      resolve: function resolve() {\n        var resolvedPath = '',\n          resolvedAbsolute = false;\n        for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n          var path = i >= 0 ? i < 0 || arguments.length <= i ? undefined : arguments[i] : FS.cwd();\n          // Skip empty and invalid entries\n          if (typeof path != 'string') {\n            throw new TypeError('Arguments to path.resolve must be strings');\n          } else if (!path) {\n            return ''; // an invalid portion invalidates the whole thing\n          }\n          resolvedPath = path + '/' + resolvedPath;\n          resolvedAbsolute = PATH.isAbs(path);\n        }\n        // At this point the path should be resolved to a full absolute path, but\n        // handle relative paths to be safe (might happen when process.cwd() fails)\n        resolvedPath = PATH.normalizeArray(resolvedPath.split('/').filter(function (p) {\n          return !!p;\n        }), !resolvedAbsolute).join('/');\n        return (resolvedAbsolute ? '/' : '') + resolvedPath || '.';\n      },\n      relative: function relative(from, to) {\n        from = PATH_FS.resolve(from).substr(1);\n        to = PATH_FS.resolve(to).substr(1);\n        function trim(arr) {\n          var start = 0;\n          for (; start < arr.length; start++) {\n            if (arr[start] !== '') break;\n          }\n          var end = arr.length - 1;\n          for (; end >= 0; end--) {\n            if (arr[end] !== '') break;\n          }\n          if (start > end) return [];\n          return arr.slice(start, end - start + 1);\n        }\n        var fromParts = trim(from.split('/'));\n        var toParts = trim(to.split('/'));\n        var length = Math.min(fromParts.length, toParts.length);\n        var samePartsLength = length;\n        for (var i = 0; i < length; i++) {\n          if (fromParts[i] !== toParts[i]) {\n            samePartsLength = i;\n            break;\n          }\n        }\n        var outputParts = [];\n        for (var i = samePartsLength; i < fromParts.length; i++) {\n          outputParts.push('..');\n        }\n        outputParts = outputParts.concat(toParts.slice(samePartsLength));\n        return outputParts.join('/');\n      }\n    };\n    var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder() : undefined;\n\n    /**\n     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given\n     * array that contains uint8 values, returns a copy of that string as a\n     * Javascript String object.\n     * heapOrArray is either a regular array, or a JavaScript typed array view.\n     * @param {number} idx\n     * @param {number=} maxBytesToRead\n     * @return {string}\n     */\n    var UTF8ArrayToString = function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {\n      var endIdx = idx + maxBytesToRead;\n      var endPtr = idx;\n      // TextDecoder needs to know the byte length in advance, it doesn't stop on\n      // null terminator by itself.  Also, use the length info to avoid running tiny\n      // strings through TextDecoder, since .subarray() allocates garbage.\n      // (As a tiny code save trick, compare endPtr against endIdx using a negation,\n      // so that undefined means Infinity)\n      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n      }\n      var str = '';\n      // If building with TextDecoder, we have already computed the string length\n      // above, so test loop end condition against that\n      while (idx < endPtr) {\n        // For UTF8 byte structure, see:\n        // http://en.wikipedia.org/wiki/UTF-8#Description\n        // https://www.ietf.org/rfc/rfc2279.txt\n        // https://tools.ietf.org/html/rfc3629\n        var u0 = heapOrArray[idx++];\n        if (!(u0 & 0x80)) {\n          str += String.fromCharCode(u0);\n          continue;\n        }\n        var u1 = heapOrArray[idx++] & 63;\n        if ((u0 & 0xE0) == 0xC0) {\n          str += String.fromCharCode((u0 & 31) << 6 | u1);\n          continue;\n        }\n        var u2 = heapOrArray[idx++] & 63;\n        if ((u0 & 0xF0) == 0xE0) {\n          u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n        } else {\n          u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;\n        }\n        if (u0 < 0x10000) {\n          str += String.fromCharCode(u0);\n        } else {\n          var ch = u0 - 0x10000;\n          str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);\n        }\n      }\n      return str;\n    };\n    var FS_stdin_getChar_buffer = [];\n    var lengthBytesUTF8 = function lengthBytesUTF8(str) {\n      var len = 0;\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\n        // unit, not a Unicode code point of the character! So decode\n        // UTF16->UTF32->UTF8.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        var c = str.charCodeAt(i); // possibly a lead surrogate\n        if (c <= 0x7F) {\n          len++;\n        } else if (c <= 0x7FF) {\n          len += 2;\n        } else if (c >= 0xD800 && c <= 0xDFFF) {\n          len += 4;\n          ++i;\n        } else {\n          len += 3;\n        }\n      }\n      return len;\n    };\n    var stringToUTF8Array = function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\n      // Parameter maxBytesToWrite is not optional. Negative values, 0, null,\n      // undefined and false each don't write out any bytes.\n      if (!(maxBytesToWrite > 0)) return 0;\n      var startIdx = outIdx;\n      var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n      for (var i = 0; i < str.length; ++i) {\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\n        // unit, not a Unicode code point of the character! So decode\n        // UTF16->UTF32->UTF8.\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\n        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description\n        // and https://www.ietf.org/rfc/rfc2279.txt\n        // and https://tools.ietf.org/html/rfc3629\n        var u = str.charCodeAt(i); // possibly a lead surrogate\n        if (u >= 0xD800 && u <= 0xDFFF) {\n          var u1 = str.charCodeAt(++i);\n          u = 0x10000 + ((u & 0x3FF) << 10) | u1 & 0x3FF;\n        }\n        if (u <= 0x7F) {\n          if (outIdx >= endIdx) break;\n          heap[outIdx++] = u;\n        } else if (u <= 0x7FF) {\n          if (outIdx + 1 >= endIdx) break;\n          heap[outIdx++] = 0xC0 | u >> 6;\n          heap[outIdx++] = 0x80 | u & 63;\n        } else if (u <= 0xFFFF) {\n          if (outIdx + 2 >= endIdx) break;\n          heap[outIdx++] = 0xE0 | u >> 12;\n          heap[outIdx++] = 0x80 | u >> 6 & 63;\n          heap[outIdx++] = 0x80 | u & 63;\n        } else {\n          if (outIdx + 3 >= endIdx) break;\n          heap[outIdx++] = 0xF0 | u >> 18;\n          heap[outIdx++] = 0x80 | u >> 12 & 63;\n          heap[outIdx++] = 0x80 | u >> 6 & 63;\n          heap[outIdx++] = 0x80 | u & 63;\n        }\n      }\n      // Null-terminate the pointer to the buffer.\n      heap[outIdx] = 0;\n      return outIdx - startIdx;\n    };\n    /** @type {function(string, boolean=, number=)} */\n    function intArrayFromString(stringy, dontAddNull, length) {\n      var len = length > 0 ? length : lengthBytesUTF8(stringy) + 1;\n      var u8array = new Array(len);\n      var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);\n      if (dontAddNull) u8array.length = numBytesWritten;\n      return u8array;\n    }\n    var FS_stdin_getChar = function FS_stdin_getChar() {\n      if (!FS_stdin_getChar_buffer.length) {\n        var result = null;\n        if (typeof window != 'undefined' && typeof window.prompt == 'function') {\n          // Browser.\n          result = window.prompt('Input: '); // returns null on cancel\n          if (result !== null) {\n            result += '\\n';\n          }\n        } else {}\n        if (!result) {\n          return null;\n        }\n        FS_stdin_getChar_buffer = intArrayFromString(result, true);\n      }\n      return FS_stdin_getChar_buffer.shift();\n    };\n    var TTY = {\n      ttys: [],\n      init: function init() {\n        // https://github.com/emscripten-core/emscripten/pull/1555\n        // if (ENVIRONMENT_IS_NODE) {\n        //   // currently, FS.init does not distinguish if process.stdin is a file or TTY\n        //   // device, it always assumes it's a TTY device. because of this, we're forcing\n        //   // process.stdin to UTF8 encoding to at least make stdin reading compatible\n        //   // with text files until FS.init can be refactored.\n        //   process.stdin.setEncoding('utf8');\n        // }\n      },\n      shutdown: function shutdown() {\n        // https://github.com/emscripten-core/emscripten/pull/1555\n        // if (ENVIRONMENT_IS_NODE) {\n        //   // inolen: any idea as to why node -e 'process.stdin.read()' wouldn't exit immediately (with process.stdin being a tty)?\n        //   // isaacs: because now it's reading from the stream, you've expressed interest in it, so that read() kicks off a _read() which creates a ReadReq operation\n        //   // inolen: I thought read() in that case was a synchronous operation that just grabbed some amount of buffered data if it exists?\n        //   // isaacs: it is. but it also triggers a _read() call, which calls readStart() on the handle\n        //   // isaacs: do process.stdin.pause() and i'd think it'd probably close the pending call\n        //   process.stdin.pause();\n        // }\n      },\n      register: function register(dev, ops) {\n        TTY.ttys[dev] = {\n          input: [],\n          output: [],\n          ops: ops\n        };\n        FS.registerDevice(dev, TTY.stream_ops);\n      },\n      stream_ops: {\n        open: function open(stream) {\n          var tty = TTY.ttys[stream.node.rdev];\n          if (!tty) {\n            throw new FS.ErrnoError(43);\n          }\n          stream.tty = tty;\n          stream.seekable = false;\n        },\n        close: function close(stream) {\n          // flush any pending line data\n          stream.tty.ops.fsync(stream.tty);\n        },\n        fsync: function fsync(stream) {\n          stream.tty.ops.fsync(stream.tty);\n        },\n        read: function read(stream, buffer, offset, length, pos /* ignored */) {\n          if (!stream.tty || !stream.tty.ops.get_char) {\n            throw new FS.ErrnoError(60);\n          }\n          var bytesRead = 0;\n          for (var i = 0; i < length; i++) {\n            var result;\n            try {\n              result = stream.tty.ops.get_char(stream.tty);\n            } catch (e) {\n              throw new FS.ErrnoError(29);\n            }\n            if (result === undefined && bytesRead === 0) {\n              throw new FS.ErrnoError(6);\n            }\n            if (result === null || result === undefined) break;\n            bytesRead++;\n            buffer[offset + i] = result;\n          }\n          if (bytesRead) {\n            stream.node.timestamp = Date.now();\n          }\n          return bytesRead;\n        },\n        write: function write(stream, buffer, offset, length, pos) {\n          if (!stream.tty || !stream.tty.ops.put_char) {\n            throw new FS.ErrnoError(60);\n          }\n          try {\n            for (var i = 0; i < length; i++) {\n              stream.tty.ops.put_char(stream.tty, buffer[offset + i]);\n            }\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n          if (length) {\n            stream.node.timestamp = Date.now();\n          }\n          return i;\n        }\n      },\n      default_tty_ops: {\n        get_char: function get_char(tty) {\n          return FS_stdin_getChar();\n        },\n        put_char: function put_char(tty, val) {\n          if (val === null || val === 10) {\n            out(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val); // val == 0 would cut text output off in the middle.\n          }\n        },\n        fsync: function fsync(tty) {\n          if (tty.output && tty.output.length > 0) {\n            out(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          }\n        },\n        ioctl_tcgets: function ioctl_tcgets(tty) {\n          // typical setting\n          return {\n            c_iflag: 25856,\n            c_oflag: 5,\n            c_cflag: 191,\n            c_lflag: 35387,\n            c_cc: [0x03, 0x1c, 0x7f, 0x15, 0x04, 0x00, 0x01, 0x00, 0x11, 0x13, 0x1a, 0x00, 0x12, 0x0f, 0x17, 0x16, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]\n          };\n        },\n        ioctl_tcsets: function ioctl_tcsets(tty, optional_actions, data) {\n          // currently just ignore\n          return 0;\n        },\n        ioctl_tiocgwinsz: function ioctl_tiocgwinsz(tty) {\n          return [24, 80];\n        }\n      },\n      default_tty1_ops: {\n        put_char: function put_char(tty, val) {\n          if (val === null || val === 10) {\n            err(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          } else {\n            if (val != 0) tty.output.push(val);\n          }\n        },\n        fsync: function fsync(tty) {\n          if (tty.output && tty.output.length > 0) {\n            err(UTF8ArrayToString(tty.output, 0));\n            tty.output = [];\n          }\n        }\n      }\n    };\n    var zeroMemory = function zeroMemory(address, size) {\n      HEAPU8.fill(0, address, address + size);\n      return address;\n    };\n    var alignMemory = function alignMemory(size, alignment) {\n      return Math.ceil(size / alignment) * alignment;\n    };\n    var mmapAlloc = function mmapAlloc(size) {\n      abort();\n    };\n    var MEMFS = {\n      ops_table: null,\n      mount: function mount(_mount) {\n        return MEMFS.createNode(null, '/', 16384 | 511 /* 0777 */, 0);\n      },\n      createNode: function createNode(parent, name, mode, dev) {\n        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {\n          // no supported\n          throw new FS.ErrnoError(63);\n        }\n        MEMFS.ops_table || (MEMFS.ops_table = {\n          dir: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr,\n              lookup: MEMFS.node_ops.lookup,\n              mknod: MEMFS.node_ops.mknod,\n              rename: MEMFS.node_ops.rename,\n              unlink: MEMFS.node_ops.unlink,\n              rmdir: MEMFS.node_ops.rmdir,\n              readdir: MEMFS.node_ops.readdir,\n              symlink: MEMFS.node_ops.symlink\n            },\n            stream: {\n              llseek: MEMFS.stream_ops.llseek\n            }\n          },\n          file: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr\n            },\n            stream: {\n              llseek: MEMFS.stream_ops.llseek,\n              read: MEMFS.stream_ops.read,\n              write: MEMFS.stream_ops.write,\n              allocate: MEMFS.stream_ops.allocate,\n              mmap: MEMFS.stream_ops.mmap,\n              msync: MEMFS.stream_ops.msync\n            }\n          },\n          link: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr,\n              readlink: MEMFS.node_ops.readlink\n            },\n            stream: {}\n          },\n          chrdev: {\n            node: {\n              getattr: MEMFS.node_ops.getattr,\n              setattr: MEMFS.node_ops.setattr\n            },\n            stream: FS.chrdev_stream_ops\n          }\n        });\n        var node = FS.createNode(parent, name, mode, dev);\n        if (FS.isDir(node.mode)) {\n          node.node_ops = MEMFS.ops_table.dir.node;\n          node.stream_ops = MEMFS.ops_table.dir.stream;\n          node.contents = {};\n        } else if (FS.isFile(node.mode)) {\n          node.node_ops = MEMFS.ops_table.file.node;\n          node.stream_ops = MEMFS.ops_table.file.stream;\n          node.usedBytes = 0; // The actual number of bytes used in the typed array, as opposed to contents.length which gives the whole capacity.\n          // When the byte data of the file is populated, this will point to either a typed array, or a normal JS array. Typed arrays are preferred\n          // for performance, and used by default. However, typed arrays are not resizable like normal JS arrays are, so there is a small disk size\n          // penalty involved for appending file writes that continuously grow a file similar to std::vector capacity vs used -scheme.\n          node.contents = null;\n        } else if (FS.isLink(node.mode)) {\n          node.node_ops = MEMFS.ops_table.link.node;\n          node.stream_ops = MEMFS.ops_table.link.stream;\n        } else if (FS.isChrdev(node.mode)) {\n          node.node_ops = MEMFS.ops_table.chrdev.node;\n          node.stream_ops = MEMFS.ops_table.chrdev.stream;\n        }\n        node.timestamp = Date.now();\n        // add the new node to the parent\n        if (parent) {\n          parent.contents[name] = node;\n          parent.timestamp = node.timestamp;\n        }\n        return node;\n      },\n      getFileDataAsTypedArray: function getFileDataAsTypedArray(node) {\n        if (!node.contents) return new Uint8Array(0);\n        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes); // Make sure to not return excess unused bytes.\n        return new Uint8Array(node.contents);\n      },\n      expandFileStorage: function expandFileStorage(node, newCapacity) {\n        var prevCapacity = node.contents ? node.contents.length : 0;\n        if (prevCapacity >= newCapacity) return; // No need to expand, the storage was already large enough.\n        // Don't expand strictly to the given requested limit if it's only a very small increase, but instead geometrically grow capacity.\n        // For small filesizes (<1MB), perform size*2 geometric increase, but for large sizes, do a much more conservative size*1.125 increase to\n        // avoid overshooting the allocation cap by a very large margin.\n        var CAPACITY_DOUBLING_MAX = 1024 * 1024;\n        newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2.0 : 1.125) >>> 0);\n        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256); // At minimum allocate 256b for each file when expanding.\n        var oldContents = node.contents;\n        node.contents = new Uint8Array(newCapacity); // Allocate new storage.\n        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0); // Copy old data over to the new storage.\n      },\n      resizeFileStorage: function resizeFileStorage(node, newSize) {\n        if (node.usedBytes == newSize) return;\n        if (newSize == 0) {\n          node.contents = null; // Fully decommit when requesting a resize to zero.\n          node.usedBytes = 0;\n        } else {\n          var oldContents = node.contents;\n          node.contents = new Uint8Array(newSize); // Allocate new storage.\n          if (oldContents) {\n            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes))); // Copy old data over to the new storage.\n          }\n          node.usedBytes = newSize;\n        }\n      },\n      node_ops: {\n        getattr: function getattr(node) {\n          var attr = {};\n          // device numbers reuse inode numbers.\n          attr.dev = FS.isChrdev(node.mode) ? node.id : 1;\n          attr.ino = node.id;\n          attr.mode = node.mode;\n          attr.nlink = 1;\n          attr.uid = 0;\n          attr.gid = 0;\n          attr.rdev = node.rdev;\n          if (FS.isDir(node.mode)) {\n            attr.size = 4096;\n          } else if (FS.isFile(node.mode)) {\n            attr.size = node.usedBytes;\n          } else if (FS.isLink(node.mode)) {\n            attr.size = node.link.length;\n          } else {\n            attr.size = 0;\n          }\n          attr.atime = new Date(node.timestamp);\n          attr.mtime = new Date(node.timestamp);\n          attr.ctime = new Date(node.timestamp);\n          // NOTE: In our implementation, st_blocks = Math.ceil(st_size/st_blksize),\n          //       but this is not required by the standard.\n          attr.blksize = 4096;\n          attr.blocks = Math.ceil(attr.size / attr.blksize);\n          return attr;\n        },\n        setattr: function setattr(node, attr) {\n          if (attr.mode !== undefined) {\n            node.mode = attr.mode;\n          }\n          if (attr.timestamp !== undefined) {\n            node.timestamp = attr.timestamp;\n          }\n          if (attr.size !== undefined) {\n            MEMFS.resizeFileStorage(node, attr.size);\n          }\n        },\n        lookup: function lookup(parent, name) {\n          throw FS.genericErrors[44];\n        },\n        mknod: function mknod(parent, name, mode, dev) {\n          return MEMFS.createNode(parent, name, mode, dev);\n        },\n        rename: function rename(old_node, new_dir, new_name) {\n          // if we're overwriting a directory at new_name, make sure it's empty.\n          if (FS.isDir(old_node.mode)) {\n            var new_node;\n            try {\n              new_node = FS.lookupNode(new_dir, new_name);\n            } catch (e) {}\n            if (new_node) {\n              for (var i in new_node.contents) {\n                throw new FS.ErrnoError(55);\n              }\n            }\n          }\n          // do the internal rewiring\n          delete old_node.parent.contents[old_node.name];\n          old_node.parent.timestamp = Date.now();\n          old_node.name = new_name;\n          new_dir.contents[new_name] = old_node;\n          new_dir.timestamp = old_node.parent.timestamp;\n        },\n        unlink: function unlink(parent, name) {\n          delete parent.contents[name];\n          parent.timestamp = Date.now();\n        },\n        rmdir: function rmdir(parent, name) {\n          var node = FS.lookupNode(parent, name);\n          for (var i in node.contents) {\n            throw new FS.ErrnoError(55);\n          }\n          delete parent.contents[name];\n          parent.timestamp = Date.now();\n        },\n        readdir: function readdir(node) {\n          var entries = ['.', '..'];\n          for (var _i = 0, _Object$keys = Object.keys(node.contents); _i < _Object$keys.length; _i++) {\n            var key = _Object$keys[_i];\n            entries.push(key);\n          }\n          return entries;\n        },\n        symlink: function symlink(parent, newname, oldpath) {\n          var node = MEMFS.createNode(parent, newname, 511 /* 0777 */ | 40960, 0);\n          node.link = oldpath;\n          return node;\n        },\n        readlink: function readlink(node) {\n          if (!FS.isLink(node.mode)) {\n            throw new FS.ErrnoError(28);\n          }\n          return node.link;\n        }\n      },\n      stream_ops: {\n        read: function read(stream, buffer, offset, length, position) {\n          var contents = stream.node.contents;\n          if (position >= stream.node.usedBytes) return 0;\n          var size = Math.min(stream.node.usedBytes - position, length);\n          if (size > 8 && contents.subarray) {\n            // non-trivial, and typed array\n            buffer.set(contents.subarray(position, position + size), offset);\n          } else {\n            for (var i = 0; i < size; i++) buffer[offset + i] = contents[position + i];\n          }\n          return size;\n        },\n        write: function write(stream, buffer, offset, length, position, canOwn) {\n          if (!length) return 0;\n          var node = stream.node;\n          node.timestamp = Date.now();\n          if (buffer.subarray && (!node.contents || node.contents.subarray)) {\n            // This write is from a typed array to a typed array?\n            if (canOwn) {\n              node.contents = buffer.subarray(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (node.usedBytes === 0 && position === 0) {\n              // If this is a simple first write to an empty file, do a fast set since we don't need to care about old data.\n              node.contents = buffer.slice(offset, offset + length);\n              node.usedBytes = length;\n              return length;\n            } else if (position + length <= node.usedBytes) {\n              // Writing to an already allocated and used subrange of the file?\n              node.contents.set(buffer.subarray(offset, offset + length), position);\n              return length;\n            }\n          }\n\n          // Appending to an existing file and we need to reallocate, or source data did not come as a typed array.\n          MEMFS.expandFileStorage(node, position + length);\n          if (node.contents.subarray && buffer.subarray) {\n            // Use typed array write which is available.\n            node.contents.set(buffer.subarray(offset, offset + length), position);\n          } else {\n            for (var i = 0; i < length; i++) {\n              node.contents[position + i] = buffer[offset + i]; // Or fall back to manual write if not.\n            }\n          }\n          node.usedBytes = Math.max(node.usedBytes, position + length);\n          return length;\n        },\n        llseek: function llseek(stream, offset, whence) {\n          var position = offset;\n          if (whence === 1) {\n            position += stream.position;\n          } else if (whence === 2) {\n            if (FS.isFile(stream.node.mode)) {\n              position += stream.node.usedBytes;\n            }\n          }\n          if (position < 0) {\n            throw new FS.ErrnoError(28);\n          }\n          return position;\n        },\n        allocate: function allocate(stream, offset, length) {\n          MEMFS.expandFileStorage(stream.node, offset + length);\n          stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length);\n        },\n        mmap: function mmap(stream, length, position, prot, flags) {\n          if (!FS.isFile(stream.node.mode)) {\n            throw new FS.ErrnoError(43);\n          }\n          var ptr;\n          var allocated;\n          var contents = stream.node.contents;\n          // Only make a new copy when MAP_PRIVATE is specified.\n          if (!(flags & 2) && contents.buffer === HEAP8.buffer) {\n            // We can't emulate MAP_SHARED when the file is not backed by the\n            // buffer we're mapping to (e.g. the HEAP buffer).\n            allocated = false;\n            ptr = contents.byteOffset;\n          } else {\n            // Try to avoid unnecessary slices.\n            if (position > 0 || position + length < contents.length) {\n              if (contents.subarray) {\n                contents = contents.subarray(position, position + length);\n              } else {\n                contents = Array.prototype.slice.call(contents, position, position + length);\n              }\n            }\n            allocated = true;\n            ptr = mmapAlloc(length);\n            if (!ptr) {\n              throw new FS.ErrnoError(48);\n            }\n            HEAP8.set(contents, ptr);\n          }\n          return {\n            ptr: ptr,\n            allocated: allocated\n          };\n        },\n        msync: function msync(stream, buffer, offset, length, mmapFlags) {\n          MEMFS.stream_ops.write(stream, buffer, 0, length, offset, false);\n          // should we check if bytesWritten and length are the same?\n          return 0;\n        }\n      }\n    };\n\n    /** @param {boolean=} noRunDep */\n    var asyncLoad = function asyncLoad(url, onload, onerror, noRunDep) {\n      var dep = !noRunDep ? getUniqueRunDependency(\"al \".concat(url)) : '';\n      readAsync(url).then(function (arrayBuffer) {\n        onload(new Uint8Array(arrayBuffer));\n        if (dep) removeRunDependency(dep);\n      }, function (err) {\n        if (onerror) {\n          onerror();\n        } else {\n          throw \"Loading data file \\\"\".concat(url, \"\\\" failed.\");\n        }\n      });\n      if (dep) addRunDependency(dep);\n    };\n    var FS_createDataFile = function FS_createDataFile(parent, name, fileData, canRead, canWrite, canOwn) {\n      FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);\n    };\n    var preloadPlugins = Module['preloadPlugins'] || [];\n    var FS_handledByPreloadPlugin = function FS_handledByPreloadPlugin(byteArray, fullname, finish, onerror) {\n      // Ensure plugins are ready.\n      if (typeof Browser != 'undefined') Browser.init();\n      var handled = false;\n      preloadPlugins.forEach(function (plugin) {\n        if (handled) return;\n        if (plugin['canHandle'](fullname)) {\n          plugin['handle'](byteArray, fullname, finish, onerror);\n          handled = true;\n        }\n      });\n      return handled;\n    };\n    var FS_createPreloadedFile = function FS_createPreloadedFile(parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) {\n      // TODO we should allow people to just pass in a complete filename instead\n      // of parent and name being that we just join them anyways\n      var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;\n      var dep = getUniqueRunDependency(\"cp \".concat(fullname)); // might have several active requests for the same fullname\n      function processData(byteArray) {\n        function finish(byteArray) {\n          preFinish === null || preFinish === void 0 || preFinish();\n          if (!dontCreateFile) {\n            FS_createDataFile(parent, name, byteArray, canRead, canWrite, canOwn);\n          }\n          onload === null || onload === void 0 || onload();\n          removeRunDependency(dep);\n        }\n        if (FS_handledByPreloadPlugin(byteArray, fullname, finish, function () {\n          onerror === null || onerror === void 0 || onerror();\n          removeRunDependency(dep);\n        })) {\n          return;\n        }\n        finish(byteArray);\n      }\n      addRunDependency(dep);\n      if (typeof url == 'string') {\n        asyncLoad(url, processData, onerror);\n      } else {\n        processData(url);\n      }\n    };\n    var FS_modeStringToFlags = function FS_modeStringToFlags(str) {\n      var flagModes = {\n        'r': 0,\n        'r+': 2,\n        'w': 512 | 64 | 1,\n        'w+': 512 | 64 | 2,\n        'a': 1024 | 64 | 1,\n        'a+': 1024 | 64 | 2\n      };\n      var flags = flagModes[str];\n      if (typeof flags == 'undefined') {\n        throw new Error(\"Unknown file open mode: \".concat(str));\n      }\n      return flags;\n    };\n    var FS_getMode = function FS_getMode(canRead, canWrite) {\n      var mode = 0;\n      if (canRead) mode |= 292 | 73;\n      if (canWrite) mode |= 146;\n      return mode;\n    };\n    var FS = {\n      root: null,\n      mounts: [],\n      devices: {},\n      streams: [],\n      nextInode: 1,\n      nameTable: null,\n      currentPath: \"/\",\n      initialized: false,\n      ignorePermissions: true,\n      ErrnoError: /*#__PURE__*/_createClass(\n      // We set the `name` property to be able to identify `FS.ErrnoError`\n      // - the `name` is a standard ECMA-262 property of error objects. Kind of good to have it anyway.\n      // - when using PROXYFS, an error can come from an underlying FS\n      // as different FS objects have their own FS.ErrnoError each,\n      // the test `err instanceof FS.ErrnoError` won't detect an error coming from another filesystem, causing bugs.\n      // we'll use the reliable test `err.name == \"ErrnoError\"` instead\n      function ErrnoError(errno) {\n        _classCallCheck(this, ErrnoError);\n        // TODO(sbc): Use the inline member declaration syntax once we\n        // support it in acorn and closure.\n        this.name = 'ErrnoError';\n        this.errno = errno;\n      }),\n      genericErrors: {},\n      filesystems: null,\n      syncFSRequests: 0,\n      FSStream: /*#__PURE__*/function () {\n        function FSStream() {\n          _classCallCheck(this, FSStream);\n          // TODO(https://github.com/emscripten-core/emscripten/issues/21414):\n          // Use inline field declarations.\n          this.shared = {};\n        }\n        return _createClass(FSStream, [{\n          key: \"object\",\n          get: function get() {\n            return this.node;\n          },\n          set: function set(val) {\n            this.node = val;\n          }\n        }, {\n          key: \"isRead\",\n          get: function get() {\n            return (this.flags & 2097155) !== 1;\n          }\n        }, {\n          key: \"isWrite\",\n          get: function get() {\n            return (this.flags & 2097155) !== 0;\n          }\n        }, {\n          key: \"isAppend\",\n          get: function get() {\n            return this.flags & 1024;\n          }\n        }, {\n          key: \"flags\",\n          get: function get() {\n            return this.shared.flags;\n          },\n          set: function set(val) {\n            this.shared.flags = val;\n          }\n        }, {\n          key: \"position\",\n          get: function get() {\n            return this.shared.position;\n          },\n          set: function set(val) {\n            this.shared.position = val;\n          }\n        }]);\n      }(),\n      FSNode: /*#__PURE__*/function () {\n        function FSNode(parent, name, mode, rdev) {\n          _classCallCheck(this, FSNode);\n          if (!parent) {\n            parent = this; // root node sets parent to itself\n          }\n          this.parent = parent;\n          this.mount = parent.mount;\n          this.mounted = null;\n          this.id = FS.nextInode++;\n          this.name = name;\n          this.mode = mode;\n          this.node_ops = {};\n          this.stream_ops = {};\n          this.rdev = rdev;\n          this.readMode = 292 /*292*/ | 73 /*73*/;\n          this.writeMode = 146 /*146*/;\n        }\n        return _createClass(FSNode, [{\n          key: \"read\",\n          get: function get() {\n            return (this.mode & this.readMode) === this.readMode;\n          },\n          set: function set(val) {\n            val ? this.mode |= this.readMode : this.mode &= ~this.readMode;\n          }\n        }, {\n          key: \"write\",\n          get: function get() {\n            return (this.mode & this.writeMode) === this.writeMode;\n          },\n          set: function set(val) {\n            val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;\n          }\n        }, {\n          key: \"isFolder\",\n          get: function get() {\n            return FS.isDir(this.mode);\n          }\n        }, {\n          key: \"isDevice\",\n          get: function get() {\n            return FS.isChrdev(this.mode);\n          }\n        }]);\n      }(),\n      lookupPath: function lookupPath(path) {\n        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        path = PATH_FS.resolve(path);\n        if (!path) return {\n          path: '',\n          node: null\n        };\n        var defaults = {\n          follow_mount: true,\n          recurse_count: 0\n        };\n        opts = Object.assign(defaults, opts);\n        if (opts.recurse_count > 8) {\n          // max recursive lookup of 8\n          throw new FS.ErrnoError(32);\n        }\n\n        // split the absolute path\n        var parts = path.split('/').filter(function (p) {\n          return !!p;\n        });\n\n        // start at the root\n        var current = FS.root;\n        var current_path = '/';\n        for (var i = 0; i < parts.length; i++) {\n          var islast = i === parts.length - 1;\n          if (islast && opts.parent) {\n            // stop resolving\n            break;\n          }\n          current = FS.lookupNode(current, parts[i]);\n          current_path = PATH.join2(current_path, parts[i]);\n\n          // jump to the mount's root node if this is a mountpoint\n          if (FS.isMountpoint(current)) {\n            if (!islast || islast && opts.follow_mount) {\n              current = current.mounted.root;\n            }\n          }\n\n          // by default, lookupPath will not follow a symlink if it is the final path component.\n          // setting opts.follow = true will override this behavior.\n          if (!islast || opts.follow) {\n            var count = 0;\n            while (FS.isLink(current.mode)) {\n              var link = FS.readlink(current_path);\n              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);\n              var lookup = FS.lookupPath(current_path, {\n                recurse_count: opts.recurse_count + 1\n              });\n              current = lookup.node;\n              if (count++ > 40) {\n                // limit max consecutive symlinks to 40 (SYMLOOP_MAX).\n                throw new FS.ErrnoError(32);\n              }\n            }\n          }\n        }\n        return {\n          path: current_path,\n          node: current\n        };\n      },\n      getPath: function getPath(node) {\n        var path;\n        while (true) {\n          if (FS.isRoot(node)) {\n            var mount = node.mount.mountpoint;\n            if (!path) return mount;\n            return mount[mount.length - 1] !== '/' ? \"\".concat(mount, \"/\").concat(path) : mount + path;\n          }\n          path = path ? \"\".concat(node.name, \"/\").concat(path) : node.name;\n          node = node.parent;\n        }\n      },\n      hashName: function hashName(parentid, name) {\n        var hash = 0;\n        for (var i = 0; i < name.length; i++) {\n          hash = (hash << 5) - hash + name.charCodeAt(i) | 0;\n        }\n        return (parentid + hash >>> 0) % FS.nameTable.length;\n      },\n      hashAddNode: function hashAddNode(node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        node.name_next = FS.nameTable[hash];\n        FS.nameTable[hash] = node;\n      },\n      hashRemoveNode: function hashRemoveNode(node) {\n        var hash = FS.hashName(node.parent.id, node.name);\n        if (FS.nameTable[hash] === node) {\n          FS.nameTable[hash] = node.name_next;\n        } else {\n          var current = FS.nameTable[hash];\n          while (current) {\n            if (current.name_next === node) {\n              current.name_next = node.name_next;\n              break;\n            }\n            current = current.name_next;\n          }\n        }\n      },\n      lookupNode: function lookupNode(parent, name) {\n        var errCode = FS.mayLookup(parent);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        var hash = FS.hashName(parent.id, name);\n        for (var node = FS.nameTable[hash]; node; node = node.name_next) {\n          var nodeName = node.name;\n          if (node.parent.id === parent.id && nodeName === name) {\n            return node;\n          }\n        }\n        // if we failed to find it in the cache, call into the VFS\n        return FS.lookup(parent, name);\n      },\n      createNode: function createNode(parent, name, mode, rdev) {\n        var node = new FS.FSNode(parent, name, mode, rdev);\n        FS.hashAddNode(node);\n        return node;\n      },\n      destroyNode: function destroyNode(node) {\n        FS.hashRemoveNode(node);\n      },\n      isRoot: function isRoot(node) {\n        return node === node.parent;\n      },\n      isMountpoint: function isMountpoint(node) {\n        return !!node.mounted;\n      },\n      isFile: function isFile(mode) {\n        return (mode & 61440) === 32768;\n      },\n      isDir: function isDir(mode) {\n        return (mode & 61440) === 16384;\n      },\n      isLink: function isLink(mode) {\n        return (mode & 61440) === 40960;\n      },\n      isChrdev: function isChrdev(mode) {\n        return (mode & 61440) === 8192;\n      },\n      isBlkdev: function isBlkdev(mode) {\n        return (mode & 61440) === 24576;\n      },\n      isFIFO: function isFIFO(mode) {\n        return (mode & 61440) === 4096;\n      },\n      isSocket: function isSocket(mode) {\n        return (mode & 49152) === 49152;\n      },\n      flagsToPermissionString: function flagsToPermissionString(flag) {\n        var perms = ['r', 'w', 'rw'][flag & 3];\n        if (flag & 512) {\n          perms += 'w';\n        }\n        return perms;\n      },\n      nodePermissions: function nodePermissions(node, perms) {\n        if (FS.ignorePermissions) {\n          return 0;\n        }\n        // return 0 if any user, group or owner bits are set.\n        if (perms.includes('r') && !(node.mode & 292)) {\n          return 2;\n        } else if (perms.includes('w') && !(node.mode & 146)) {\n          return 2;\n        } else if (perms.includes('x') && !(node.mode & 73)) {\n          return 2;\n        }\n        return 0;\n      },\n      mayLookup: function mayLookup(dir) {\n        if (!FS.isDir(dir.mode)) return 54;\n        var errCode = FS.nodePermissions(dir, 'x');\n        if (errCode) return errCode;\n        if (!dir.node_ops.lookup) return 2;\n        return 0;\n      },\n      mayCreate: function mayCreate(dir, name) {\n        try {\n          var node = FS.lookupNode(dir, name);\n          return 20;\n        } catch (e) {}\n        return FS.nodePermissions(dir, 'wx');\n      },\n      mayDelete: function mayDelete(dir, name, isdir) {\n        var node;\n        try {\n          node = FS.lookupNode(dir, name);\n        } catch (e) {\n          return e.errno;\n        }\n        var errCode = FS.nodePermissions(dir, 'wx');\n        if (errCode) {\n          return errCode;\n        }\n        if (isdir) {\n          if (!FS.isDir(node.mode)) {\n            return 54;\n          }\n          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {\n            return 10;\n          }\n        } else {\n          if (FS.isDir(node.mode)) {\n            return 31;\n          }\n        }\n        return 0;\n      },\n      mayOpen: function mayOpen(node, flags) {\n        if (!node) {\n          return 44;\n        }\n        if (FS.isLink(node.mode)) {\n          return 32;\n        } else if (FS.isDir(node.mode)) {\n          if (FS.flagsToPermissionString(flags) !== 'r' ||\n          // opening for write\n          flags & 512) {\n            // TODO: check for O_SEARCH? (== search for dir only)\n            return 31;\n          }\n        }\n        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));\n      },\n      MAX_OPEN_FDS: 4096,\n      nextfd: function nextfd() {\n        for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {\n          if (!FS.streams[fd]) {\n            return fd;\n          }\n        }\n        throw new FS.ErrnoError(33);\n      },\n      getStreamChecked: function getStreamChecked(fd) {\n        var stream = FS.getStream(fd);\n        if (!stream) {\n          throw new FS.ErrnoError(8);\n        }\n        return stream;\n      },\n      getStream: function getStream(fd) {\n        return FS.streams[fd];\n      },\n      createStream: function createStream(stream) {\n        var fd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n        // clone it, so we can return an instance of FSStream\n        stream = Object.assign(new FS.FSStream(), stream);\n        if (fd == -1) {\n          fd = FS.nextfd();\n        }\n        stream.fd = fd;\n        FS.streams[fd] = stream;\n        return stream;\n      },\n      closeStream: function closeStream(fd) {\n        FS.streams[fd] = null;\n      },\n      dupStream: function dupStream(origStream) {\n        var _stream$stream_ops, _stream$stream_ops$du;\n        var fd = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : -1;\n        var stream = FS.createStream(origStream, fd);\n        (_stream$stream_ops = stream.stream_ops) === null || _stream$stream_ops === void 0 || (_stream$stream_ops$du = _stream$stream_ops.dup) === null || _stream$stream_ops$du === void 0 || _stream$stream_ops$du.call(_stream$stream_ops, stream);\n        return stream;\n      },\n      chrdev_stream_ops: {\n        open: function open(stream) {\n          var _stream$stream_ops$op, _stream$stream_ops2;\n          var device = FS.getDevice(stream.node.rdev);\n          // override node's stream ops with the device's\n          stream.stream_ops = device.stream_ops;\n          // forward the open call\n          (_stream$stream_ops$op = (_stream$stream_ops2 = stream.stream_ops).open) === null || _stream$stream_ops$op === void 0 || _stream$stream_ops$op.call(_stream$stream_ops2, stream);\n        },\n        llseek: function llseek() {\n          throw new FS.ErrnoError(70);\n        }\n      },\n      major: function major(dev) {\n        return dev >> 8;\n      },\n      minor: function minor(dev) {\n        return dev & 0xff;\n      },\n      makedev: function makedev(ma, mi) {\n        return ma << 8 | mi;\n      },\n      registerDevice: function registerDevice(dev, ops) {\n        FS.devices[dev] = {\n          stream_ops: ops\n        };\n      },\n      getDevice: function getDevice(dev) {\n        return FS.devices[dev];\n      },\n      getMounts: function getMounts(mount) {\n        var mounts = [];\n        var check = [mount];\n        while (check.length) {\n          var m = check.pop();\n          mounts.push(m);\n          check.push.apply(check, _toConsumableArray(m.mounts));\n        }\n        return mounts;\n      },\n      syncfs: function syncfs(populate, callback) {\n        if (typeof populate == 'function') {\n          callback = populate;\n          populate = false;\n        }\n        FS.syncFSRequests++;\n        if (FS.syncFSRequests > 1) {\n          err(\"warning: \".concat(FS.syncFSRequests, \" FS.syncfs operations in flight at once, probably just doing extra work\"));\n        }\n        var mounts = FS.getMounts(FS.root.mount);\n        var completed = 0;\n        function doCallback(errCode) {\n          FS.syncFSRequests--;\n          return callback(errCode);\n        }\n        function done(errCode) {\n          if (errCode) {\n            if (!done.errored) {\n              done.errored = true;\n              return doCallback(errCode);\n            }\n            return;\n          }\n          if (++completed >= mounts.length) {\n            doCallback(null);\n          }\n        }\n        ;\n\n        // sync all mounts\n        mounts.forEach(function (mount) {\n          if (!mount.type.syncfs) {\n            return done(null);\n          }\n          mount.type.syncfs(mount, populate, done);\n        });\n      },\n      mount: function mount(type, opts, mountpoint) {\n        var root = mountpoint === '/';\n        var pseudo = !mountpoint;\n        var node;\n        if (root && FS.root) {\n          throw new FS.ErrnoError(10);\n        } else if (!root && !pseudo) {\n          var lookup = FS.lookupPath(mountpoint, {\n            follow_mount: false\n          });\n          mountpoint = lookup.path; // use the absolute path\n          node = lookup.node;\n          if (FS.isMountpoint(node)) {\n            throw new FS.ErrnoError(10);\n          }\n          if (!FS.isDir(node.mode)) {\n            throw new FS.ErrnoError(54);\n          }\n        }\n        var mount = {\n          type: type,\n          opts: opts,\n          mountpoint: mountpoint,\n          mounts: []\n        };\n\n        // create a root node for the fs\n        var mountRoot = type.mount(mount);\n        mountRoot.mount = mount;\n        mount.root = mountRoot;\n        if (root) {\n          FS.root = mountRoot;\n        } else if (node) {\n          // set as a mountpoint\n          node.mounted = mount;\n\n          // add the new mount to the current mount's children\n          if (node.mount) {\n            node.mount.mounts.push(mount);\n          }\n        }\n        return mountRoot;\n      },\n      unmount: function unmount(mountpoint) {\n        var lookup = FS.lookupPath(mountpoint, {\n          follow_mount: false\n        });\n        if (!FS.isMountpoint(lookup.node)) {\n          throw new FS.ErrnoError(28);\n        }\n\n        // destroy the nodes for this mount, and all its child mounts\n        var node = lookup.node;\n        var mount = node.mounted;\n        var mounts = FS.getMounts(mount);\n        Object.keys(FS.nameTable).forEach(function (hash) {\n          var current = FS.nameTable[hash];\n          while (current) {\n            var next = current.name_next;\n            if (mounts.includes(current.mount)) {\n              FS.destroyNode(current);\n            }\n            current = next;\n          }\n        });\n\n        // no longer a mountpoint\n        node.mounted = null;\n\n        // remove this mount from the child mounts\n        var idx = node.mount.mounts.indexOf(mount);\n        node.mount.mounts.splice(idx, 1);\n      },\n      lookup: function lookup(parent, name) {\n        return parent.node_ops.lookup(parent, name);\n      },\n      mknod: function mknod(path, mode, dev) {\n        var lookup = FS.lookupPath(path, {\n          parent: true\n        });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        if (!name || name === '.' || name === '..') {\n          throw new FS.ErrnoError(28);\n        }\n        var errCode = FS.mayCreate(parent, name);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.mknod) {\n          throw new FS.ErrnoError(63);\n        }\n        return parent.node_ops.mknod(parent, name, mode, dev);\n      },\n      create: function create(path, mode) {\n        mode = mode !== undefined ? mode : 438 /* 0666 */;\n        mode &= 4095;\n        mode |= 32768;\n        return FS.mknod(path, mode, 0);\n      },\n      mkdir: function mkdir(path, mode) {\n        mode = mode !== undefined ? mode : 511 /* 0777 */;\n        mode &= 511 | 512;\n        mode |= 16384;\n        return FS.mknod(path, mode, 0);\n      },\n      mkdirTree: function mkdirTree(path, mode) {\n        var dirs = path.split('/');\n        var d = '';\n        for (var i = 0; i < dirs.length; ++i) {\n          if (!dirs[i]) continue;\n          d += '/' + dirs[i];\n          try {\n            FS.mkdir(d, mode);\n          } catch (e) {\n            if (e.errno != 20) throw e;\n          }\n        }\n      },\n      mkdev: function mkdev(path, mode, dev) {\n        if (typeof dev == 'undefined') {\n          dev = mode;\n          mode = 438 /* 0666 */;\n        }\n        mode |= 8192;\n        return FS.mknod(path, mode, dev);\n      },\n      symlink: function symlink(oldpath, newpath) {\n        if (!PATH_FS.resolve(oldpath)) {\n          throw new FS.ErrnoError(44);\n        }\n        var lookup = FS.lookupPath(newpath, {\n          parent: true\n        });\n        var parent = lookup.node;\n        if (!parent) {\n          throw new FS.ErrnoError(44);\n        }\n        var newname = PATH.basename(newpath);\n        var errCode = FS.mayCreate(parent, newname);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.symlink) {\n          throw new FS.ErrnoError(63);\n        }\n        return parent.node_ops.symlink(parent, newname, oldpath);\n      },\n      rename: function rename(old_path, new_path) {\n        var old_dirname = PATH.dirname(old_path);\n        var new_dirname = PATH.dirname(new_path);\n        var old_name = PATH.basename(old_path);\n        var new_name = PATH.basename(new_path);\n        // parents must exist\n        var lookup, old_dir, new_dir;\n\n        // let the errors from non existent directories percolate up\n        lookup = FS.lookupPath(old_path, {\n          parent: true\n        });\n        old_dir = lookup.node;\n        lookup = FS.lookupPath(new_path, {\n          parent: true\n        });\n        new_dir = lookup.node;\n        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);\n        // need to be part of the same mount\n        if (old_dir.mount !== new_dir.mount) {\n          throw new FS.ErrnoError(75);\n        }\n        // source must exist\n        var old_node = FS.lookupNode(old_dir, old_name);\n        // old path should not be an ancestor of the new path\n        var relative = PATH_FS.relative(old_path, new_dirname);\n        if (relative.charAt(0) !== '.') {\n          throw new FS.ErrnoError(28);\n        }\n        // new path should not be an ancestor of the old path\n        relative = PATH_FS.relative(new_path, old_dirname);\n        if (relative.charAt(0) !== '.') {\n          throw new FS.ErrnoError(55);\n        }\n        // see if the new path already exists\n        var new_node;\n        try {\n          new_node = FS.lookupNode(new_dir, new_name);\n        } catch (e) {\n          // not fatal\n        }\n        // early out if nothing needs to change\n        if (old_node === new_node) {\n          return;\n        }\n        // we'll need to delete the old entry\n        var isdir = FS.isDir(old_node.mode);\n        var errCode = FS.mayDelete(old_dir, old_name, isdir);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        // need delete permissions if we'll be overwriting.\n        // need create permissions if new doesn't already exist.\n        errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!old_dir.node_ops.rename) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {\n          throw new FS.ErrnoError(10);\n        }\n        // if we are going to change the parent, check write permissions\n        if (new_dir !== old_dir) {\n          errCode = FS.nodePermissions(old_dir, 'w');\n          if (errCode) {\n            throw new FS.ErrnoError(errCode);\n          }\n        }\n        // remove the node from the lookup hash\n        FS.hashRemoveNode(old_node);\n        // do the underlying fs rename\n        try {\n          old_dir.node_ops.rename(old_node, new_dir, new_name);\n          // update old node (we do this here to avoid each backend \n          // needing to)\n          old_node.parent = new_dir;\n        } catch (e) {\n          throw e;\n        } finally {\n          // add the node back to the hash (in case node_ops.rename\n          // changed its name)\n          FS.hashAddNode(old_node);\n        }\n      },\n      rmdir: function rmdir(path) {\n        var lookup = FS.lookupPath(path, {\n          parent: true\n        });\n        var parent = lookup.node;\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var errCode = FS.mayDelete(parent, name, true);\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.rmdir) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n        parent.node_ops.rmdir(parent, name);\n        FS.destroyNode(node);\n      },\n      readdir: function readdir(path) {\n        var lookup = FS.lookupPath(path, {\n          follow: true\n        });\n        var node = lookup.node;\n        if (!node.node_ops.readdir) {\n          throw new FS.ErrnoError(54);\n        }\n        return node.node_ops.readdir(node);\n      },\n      unlink: function unlink(path) {\n        var lookup = FS.lookupPath(path, {\n          parent: true\n        });\n        var parent = lookup.node;\n        if (!parent) {\n          throw new FS.ErrnoError(44);\n        }\n        var name = PATH.basename(path);\n        var node = FS.lookupNode(parent, name);\n        var errCode = FS.mayDelete(parent, name, false);\n        if (errCode) {\n          // According to POSIX, we should map EISDIR to EPERM, but\n          // we instead do what Linux does (and we must, as we use\n          // the musl linux libc).\n          throw new FS.ErrnoError(errCode);\n        }\n        if (!parent.node_ops.unlink) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isMountpoint(node)) {\n          throw new FS.ErrnoError(10);\n        }\n        parent.node_ops.unlink(parent, name);\n        FS.destroyNode(node);\n      },\n      readlink: function readlink(path) {\n        var lookup = FS.lookupPath(path);\n        var link = lookup.node;\n        if (!link) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!link.node_ops.readlink) {\n          throw new FS.ErrnoError(28);\n        }\n        return PATH_FS.resolve(FS.getPath(link.parent), link.node_ops.readlink(link));\n      },\n      stat: function stat(path, dontFollow) {\n        var lookup = FS.lookupPath(path, {\n          follow: !dontFollow\n        });\n        var node = lookup.node;\n        if (!node) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!node.node_ops.getattr) {\n          throw new FS.ErrnoError(63);\n        }\n        return node.node_ops.getattr(node);\n      },\n      lstat: function lstat(path) {\n        return FS.stat(path, true);\n      },\n      chmod: function chmod(path, mode, dontFollow) {\n        var node;\n        if (typeof path == 'string') {\n          var lookup = FS.lookupPath(path, {\n            follow: !dontFollow\n          });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        node.node_ops.setattr(node, {\n          mode: mode & 4095 | node.mode & ~4095,\n          timestamp: Date.now()\n        });\n      },\n      lchmod: function lchmod(path, mode) {\n        FS.chmod(path, mode, true);\n      },\n      fchmod: function fchmod(fd, mode) {\n        var stream = FS.getStreamChecked(fd);\n        FS.chmod(stream.node, mode);\n      },\n      chown: function chown(path, uid, gid, dontFollow) {\n        var node;\n        if (typeof path == 'string') {\n          var lookup = FS.lookupPath(path, {\n            follow: !dontFollow\n          });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        node.node_ops.setattr(node, {\n          timestamp: Date.now()\n          // we ignore the uid / gid for now\n        });\n      },\n      lchown: function lchown(path, uid, gid) {\n        FS.chown(path, uid, gid, true);\n      },\n      fchown: function fchown(fd, uid, gid) {\n        var stream = FS.getStreamChecked(fd);\n        FS.chown(stream.node, uid, gid);\n      },\n      truncate: function truncate(path, len) {\n        if (len < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        var node;\n        if (typeof path == 'string') {\n          var lookup = FS.lookupPath(path, {\n            follow: true\n          });\n          node = lookup.node;\n        } else {\n          node = path;\n        }\n        if (!node.node_ops.setattr) {\n          throw new FS.ErrnoError(63);\n        }\n        if (FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!FS.isFile(node.mode)) {\n          throw new FS.ErrnoError(28);\n        }\n        var errCode = FS.nodePermissions(node, 'w');\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        node.node_ops.setattr(node, {\n          size: len,\n          timestamp: Date.now()\n        });\n      },\n      ftruncate: function ftruncate(fd, len) {\n        var stream = FS.getStreamChecked(fd);\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(28);\n        }\n        FS.truncate(stream.node, len);\n      },\n      utime: function utime(path, atime, mtime) {\n        var lookup = FS.lookupPath(path, {\n          follow: true\n        });\n        var node = lookup.node;\n        node.node_ops.setattr(node, {\n          timestamp: Math.max(atime, mtime)\n        });\n      },\n      open: function open(path, flags, mode) {\n        if (path === \"\") {\n          throw new FS.ErrnoError(44);\n        }\n        flags = typeof flags == 'string' ? FS_modeStringToFlags(flags) : flags;\n        if (flags & 64) {\n          mode = typeof mode == 'undefined' ? 438 /* 0666 */ : mode;\n          mode = mode & 4095 | 32768;\n        } else {\n          mode = 0;\n        }\n        var node;\n        if (_typeof(path) == 'object') {\n          node = path;\n        } else {\n          path = PATH.normalize(path);\n          try {\n            var lookup = FS.lookupPath(path, {\n              follow: !(flags & 131072)\n            });\n            node = lookup.node;\n          } catch (e) {\n            // ignore\n          }\n        }\n        // perhaps we need to create the node\n        var created = false;\n        if (flags & 64) {\n          if (node) {\n            // if O_CREAT and O_EXCL are set, error out if the node already exists\n            if (flags & 128) {\n              throw new FS.ErrnoError(20);\n            }\n          } else {\n            // node doesn't exist, try to create it\n            node = FS.mknod(path, mode, 0);\n            created = true;\n          }\n        }\n        if (!node) {\n          throw new FS.ErrnoError(44);\n        }\n        // can't truncate a device\n        if (FS.isChrdev(node.mode)) {\n          flags &= ~512;\n        }\n        // if asked only for a directory, then this must be one\n        if (flags & 65536 && !FS.isDir(node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n        // check permissions, if this is not a file we just created now (it is ok to\n        // create and write to a file with read-only permissions; it is read-only\n        // for later use)\n        if (!created) {\n          var errCode = FS.mayOpen(node, flags);\n          if (errCode) {\n            throw new FS.ErrnoError(errCode);\n          }\n        }\n        // do truncation if necessary\n        if (flags & 512 && !created) {\n          FS.truncate(node, 0);\n        }\n        // we've already handled these, don't pass down to the underlying vfs\n        flags &= ~(128 | 512 | 131072);\n\n        // register the stream with the filesystem\n        var stream = FS.createStream({\n          node: node,\n          path: FS.getPath(node),\n          // we want the absolute path to the node\n          flags: flags,\n          seekable: true,\n          position: 0,\n          stream_ops: node.stream_ops,\n          // used by the file family libc calls (fopen, fwrite, ferror, etc.)\n          ungotten: [],\n          error: false\n        });\n        // call the new stream's open function\n        if (stream.stream_ops.open) {\n          stream.stream_ops.open(stream);\n        }\n        if (Module['logReadFiles'] && !(flags & 1)) {\n          if (!FS.readFiles) FS.readFiles = {};\n          if (!(path in FS.readFiles)) {\n            FS.readFiles[path] = 1;\n          }\n        }\n        return stream;\n      },\n      close: function close(stream) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (stream.getdents) stream.getdents = null; // free readdir state\n        try {\n          if (stream.stream_ops.close) {\n            stream.stream_ops.close(stream);\n          }\n        } catch (e) {\n          throw e;\n        } finally {\n          FS.closeStream(stream.fd);\n        }\n        stream.fd = null;\n      },\n      isClosed: function isClosed(stream) {\n        return stream.fd === null;\n      },\n      llseek: function llseek(stream, offset, whence) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (!stream.seekable || !stream.stream_ops.llseek) {\n          throw new FS.ErrnoError(70);\n        }\n        if (whence != 0 && whence != 1 && whence != 2) {\n          throw new FS.ErrnoError(28);\n        }\n        stream.position = stream.stream_ops.llseek(stream, offset, whence);\n        stream.ungotten = [];\n        return stream.position;\n      },\n      read: function read(stream, buffer, offset, length, position) {\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(8);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!stream.stream_ops.read) {\n          throw new FS.ErrnoError(28);\n        }\n        var seeking = typeof position != 'undefined';\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(70);\n        }\n        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length, position);\n        if (!seeking) stream.position += bytesRead;\n        return bytesRead;\n      },\n      write: function write(stream, buffer, offset, length, position, canOwn) {\n        if (length < 0 || position < 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(8);\n        }\n        if (FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(31);\n        }\n        if (!stream.stream_ops.write) {\n          throw new FS.ErrnoError(28);\n        }\n        if (stream.seekable && stream.flags & 1024) {\n          // seek to the end before writing in append mode\n          FS.llseek(stream, 0, 2);\n        }\n        var seeking = typeof position != 'undefined';\n        if (!seeking) {\n          position = stream.position;\n        } else if (!stream.seekable) {\n          throw new FS.ErrnoError(70);\n        }\n        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length, position, canOwn);\n        if (!seeking) stream.position += bytesWritten;\n        return bytesWritten;\n      },\n      allocate: function allocate(stream, offset, length) {\n        if (FS.isClosed(stream)) {\n          throw new FS.ErrnoError(8);\n        }\n        if (offset < 0 || length <= 0) {\n          throw new FS.ErrnoError(28);\n        }\n        if ((stream.flags & 2097155) === 0) {\n          throw new FS.ErrnoError(8);\n        }\n        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {\n          throw new FS.ErrnoError(43);\n        }\n        if (!stream.stream_ops.allocate) {\n          throw new FS.ErrnoError(138);\n        }\n        stream.stream_ops.allocate(stream, offset, length);\n      },\n      mmap: function mmap(stream, length, position, prot, flags) {\n        // User requests writing to file (prot & PROT_WRITE != 0).\n        // Checking if we have permissions to write to the file unless\n        // MAP_PRIVATE flag is set. According to POSIX spec it is possible\n        // to write to file opened in read-only mode with MAP_PRIVATE flag,\n        // as all modifications will be visible only in the memory of\n        // the current process.\n        if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {\n          throw new FS.ErrnoError(2);\n        }\n        if ((stream.flags & 2097155) === 1) {\n          throw new FS.ErrnoError(2);\n        }\n        if (!stream.stream_ops.mmap) {\n          throw new FS.ErrnoError(43);\n        }\n        return stream.stream_ops.mmap(stream, length, position, prot, flags);\n      },\n      msync: function msync(stream, buffer, offset, length, mmapFlags) {\n        if (!stream.stream_ops.msync) {\n          return 0;\n        }\n        return stream.stream_ops.msync(stream, buffer, offset, length, mmapFlags);\n      },\n      ioctl: function ioctl(stream, cmd, arg) {\n        if (!stream.stream_ops.ioctl) {\n          throw new FS.ErrnoError(59);\n        }\n        return stream.stream_ops.ioctl(stream, cmd, arg);\n      },\n      readFile: function readFile(path) {\n        var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n        opts.flags = opts.flags || 0;\n        opts.encoding = opts.encoding || 'binary';\n        if (opts.encoding !== 'utf8' && opts.encoding !== 'binary') {\n          throw new Error(\"Invalid encoding type \\\"\".concat(opts.encoding, \"\\\"\"));\n        }\n        var ret;\n        var stream = FS.open(path, opts.flags);\n        var stat = FS.stat(path);\n        var length = stat.size;\n        var buf = new Uint8Array(length);\n        FS.read(stream, buf, 0, length, 0);\n        if (opts.encoding === 'utf8') {\n          ret = UTF8ArrayToString(buf, 0);\n        } else if (opts.encoding === 'binary') {\n          ret = buf;\n        }\n        FS.close(stream);\n        return ret;\n      },\n      writeFile: function writeFile(path, data) {\n        var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n        opts.flags = opts.flags || 577;\n        var stream = FS.open(path, opts.flags, opts.mode);\n        if (typeof data == 'string') {\n          var buf = new Uint8Array(lengthBytesUTF8(data) + 1);\n          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);\n          FS.write(stream, buf, 0, actualNumBytes, undefined, opts.canOwn);\n        } else if (ArrayBuffer.isView(data)) {\n          FS.write(stream, data, 0, data.byteLength, undefined, opts.canOwn);\n        } else {\n          throw new Error('Unsupported data type');\n        }\n        FS.close(stream);\n      },\n      cwd: function cwd() {\n        return FS.currentPath;\n      },\n      chdir: function chdir(path) {\n        var lookup = FS.lookupPath(path, {\n          follow: true\n        });\n        if (lookup.node === null) {\n          throw new FS.ErrnoError(44);\n        }\n        if (!FS.isDir(lookup.node.mode)) {\n          throw new FS.ErrnoError(54);\n        }\n        var errCode = FS.nodePermissions(lookup.node, 'x');\n        if (errCode) {\n          throw new FS.ErrnoError(errCode);\n        }\n        FS.currentPath = lookup.path;\n      },\n      createDefaultDirectories: function createDefaultDirectories() {\n        FS.mkdir('/tmp');\n        FS.mkdir('/home');\n        FS.mkdir('/home/web_user');\n      },\n      createDefaultDevices: function createDefaultDevices() {\n        // create /dev\n        FS.mkdir('/dev');\n        // setup /dev/null\n        FS.registerDevice(FS.makedev(1, 3), {\n          read: function read() {\n            return 0;\n          },\n          write: function write(stream, buffer, offset, length, pos) {\n            return length;\n          }\n        });\n        FS.mkdev('/dev/null', FS.makedev(1, 3));\n        // setup /dev/tty and /dev/tty1\n        // stderr needs to print output using err() rather than out()\n        // so we register a second tty just for it.\n        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);\n        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);\n        FS.mkdev('/dev/tty', FS.makedev(5, 0));\n        FS.mkdev('/dev/tty1', FS.makedev(6, 0));\n        // setup /dev/[u]random\n        // use a buffer to avoid overhead of individual crypto calls per byte\n        var randomBuffer = new Uint8Array(1024),\n          randomLeft = 0;\n        var randomByte = function randomByte() {\n          if (randomLeft === 0) {\n            randomLeft = _randomFill(randomBuffer).byteLength;\n          }\n          return randomBuffer[--randomLeft];\n        };\n        FS.createDevice('/dev', 'random', randomByte);\n        FS.createDevice('/dev', 'urandom', randomByte);\n        // we're not going to emulate the actual shm device,\n        // just create the tmp dirs that reside in it commonly\n        FS.mkdir('/dev/shm');\n        FS.mkdir('/dev/shm/tmp');\n      },\n      createSpecialDirectories: function createSpecialDirectories() {\n        // create /proc/self/fd which allows /proc/self/fd/6 => readlink gives the\n        // name of the stream for fd 6 (see test_unistd_ttyname)\n        FS.mkdir('/proc');\n        var proc_self = FS.mkdir('/proc/self');\n        FS.mkdir('/proc/self/fd');\n        FS.mount({\n          mount: function mount() {\n            var node = FS.createNode(proc_self, 'fd', 16384 | 511 /* 0777 */, 73);\n            node.node_ops = {\n              lookup: function lookup(parent, name) {\n                var fd = +name;\n                var stream = FS.getStreamChecked(fd);\n                var ret = {\n                  parent: null,\n                  mount: {\n                    mountpoint: 'fake'\n                  },\n                  node_ops: {\n                    readlink: function readlink() {\n                      return stream.path;\n                    }\n                  }\n                };\n                ret.parent = ret; // make it look like a simple root node\n                return ret;\n              }\n            };\n            return node;\n          }\n        }, {}, '/proc/self/fd');\n      },\n      createStandardStreams: function createStandardStreams() {\n        // TODO deprecate the old functionality of a single\n        // input / output callback and that utilizes FS.createDevice\n        // and instead require a unique set of stream ops\n\n        // by default, we symlink the standard streams to the\n        // default tty devices. however, if the standard streams\n        // have been overwritten we create a unique device for\n        // them instead.\n        if (Module['stdin']) {\n          FS.createDevice('/dev', 'stdin', Module['stdin']);\n        } else {\n          FS.symlink('/dev/tty', '/dev/stdin');\n        }\n        if (Module['stdout']) {\n          FS.createDevice('/dev', 'stdout', null, Module['stdout']);\n        } else {\n          FS.symlink('/dev/tty', '/dev/stdout');\n        }\n        if (Module['stderr']) {\n          FS.createDevice('/dev', 'stderr', null, Module['stderr']);\n        } else {\n          FS.symlink('/dev/tty1', '/dev/stderr');\n        }\n\n        // open default streams for the stdin, stdout and stderr devices\n        var stdin = FS.open('/dev/stdin', 0);\n        var stdout = FS.open('/dev/stdout', 1);\n        var stderr = FS.open('/dev/stderr', 1);\n      },\n      staticInit: function staticInit() {\n        // Some errors may happen quite a bit, to avoid overhead we reuse them (and suffer a lack of stack info)\n        [44].forEach(function (code) {\n          FS.genericErrors[code] = new FS.ErrnoError(code);\n          FS.genericErrors[code].stack = '<generic error, no stack>';\n        });\n        FS.nameTable = new Array(4096);\n        FS.mount(MEMFS, {}, '/');\n        FS.createDefaultDirectories();\n        FS.createDefaultDevices();\n        FS.createSpecialDirectories();\n        FS.filesystems = {\n          'MEMFS': MEMFS\n        };\n      },\n      init: function init(input, output, error) {\n        FS.init.initialized = true;\n\n        // Allow Module.stdin etc. to provide defaults, if none explicitly passed to us here\n        Module['stdin'] = input || Module['stdin'];\n        Module['stdout'] = output || Module['stdout'];\n        Module['stderr'] = error || Module['stderr'];\n        FS.createStandardStreams();\n      },\n      quit: function quit() {\n        FS.init.initialized = false;\n        // force-flush all streams, so we get musl std streams printed out\n        // close all of our streams\n        for (var i = 0; i < FS.streams.length; i++) {\n          var stream = FS.streams[i];\n          if (!stream) {\n            continue;\n          }\n          FS.close(stream);\n        }\n      },\n      findObject: function findObject(path, dontResolveLastLink) {\n        var ret = FS.analyzePath(path, dontResolveLastLink);\n        if (!ret.exists) {\n          return null;\n        }\n        return ret.object;\n      },\n      analyzePath: function analyzePath(path, dontResolveLastLink) {\n        // operate from within the context of the symlink's target\n        try {\n          var lookup = FS.lookupPath(path, {\n            follow: !dontResolveLastLink\n          });\n          path = lookup.path;\n        } catch (e) {}\n        var ret = {\n          isRoot: false,\n          exists: false,\n          error: 0,\n          name: null,\n          path: null,\n          object: null,\n          parentExists: false,\n          parentPath: null,\n          parentObject: null\n        };\n        try {\n          var lookup = FS.lookupPath(path, {\n            parent: true\n          });\n          ret.parentExists = true;\n          ret.parentPath = lookup.path;\n          ret.parentObject = lookup.node;\n          ret.name = PATH.basename(path);\n          lookup = FS.lookupPath(path, {\n            follow: !dontResolveLastLink\n          });\n          ret.exists = true;\n          ret.path = lookup.path;\n          ret.object = lookup.node;\n          ret.name = lookup.node.name;\n          ret.isRoot = lookup.path === '/';\n        } catch (e) {\n          ret.error = e.errno;\n        }\n        ;\n        return ret;\n      },\n      createPath: function createPath(parent, path, canRead, canWrite) {\n        parent = typeof parent == 'string' ? parent : FS.getPath(parent);\n        var parts = path.split('/').reverse();\n        while (parts.length) {\n          var part = parts.pop();\n          if (!part) continue;\n          var current = PATH.join2(parent, part);\n          try {\n            FS.mkdir(current);\n          } catch (e) {\n            // ignore EEXIST\n          }\n          parent = current;\n        }\n        return current;\n      },\n      createFile: function createFile(parent, name, properties, canRead, canWrite) {\n        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);\n        var mode = FS_getMode(canRead, canWrite);\n        return FS.create(path, mode);\n      },\n      createDataFile: function createDataFile(parent, name, data, canRead, canWrite, canOwn) {\n        var path = name;\n        if (parent) {\n          parent = typeof parent == 'string' ? parent : FS.getPath(parent);\n          path = name ? PATH.join2(parent, name) : parent;\n        }\n        var mode = FS_getMode(canRead, canWrite);\n        var node = FS.create(path, mode);\n        if (data) {\n          if (typeof data == 'string') {\n            var arr = new Array(data.length);\n            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);\n            data = arr;\n          }\n          // make sure we can write to the file\n          FS.chmod(node, mode | 146);\n          var stream = FS.open(node, 577);\n          FS.write(stream, data, 0, data.length, 0, canOwn);\n          FS.close(stream);\n          FS.chmod(node, mode);\n        }\n      },\n      createDevice: function createDevice(parent, name, input, output) {\n        var path = PATH.join2(typeof parent == 'string' ? parent : FS.getPath(parent), name);\n        var mode = FS_getMode(!!input, !!output);\n        if (!FS.createDevice.major) FS.createDevice.major = 64;\n        var dev = FS.makedev(FS.createDevice.major++, 0);\n        // Create a fake device that a set of stream ops to emulate\n        // the old behavior.\n        FS.registerDevice(dev, {\n          open: function open(stream) {\n            stream.seekable = false;\n          },\n          close: function close(stream) {\n            var _output$buffer;\n            // flush any pending line data\n            if (output !== null && output !== void 0 && (_output$buffer = output.buffer) !== null && _output$buffer !== void 0 && _output$buffer.length) {\n              output(10);\n            }\n          },\n          read: function read(stream, buffer, offset, length, pos /* ignored */) {\n            var bytesRead = 0;\n            for (var i = 0; i < length; i++) {\n              var result;\n              try {\n                result = input();\n              } catch (e) {\n                throw new FS.ErrnoError(29);\n              }\n              if (result === undefined && bytesRead === 0) {\n                throw new FS.ErrnoError(6);\n              }\n              if (result === null || result === undefined) break;\n              bytesRead++;\n              buffer[offset + i] = result;\n            }\n            if (bytesRead) {\n              stream.node.timestamp = Date.now();\n            }\n            return bytesRead;\n          },\n          write: function write(stream, buffer, offset, length, pos) {\n            for (var i = 0; i < length; i++) {\n              try {\n                output(buffer[offset + i]);\n              } catch (e) {\n                throw new FS.ErrnoError(29);\n              }\n            }\n            if (length) {\n              stream.node.timestamp = Date.now();\n            }\n            return i;\n          }\n        });\n        return FS.mkdev(path, mode, dev);\n      },\n      forceLoadFile: function forceLoadFile(obj) {\n        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;\n        if (typeof XMLHttpRequest != 'undefined') {\n          throw new Error(\"Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.\");\n        } else {\n          // Command-line.\n          try {\n            obj.contents = readBinary(obj.url);\n            obj.usedBytes = obj.contents.length;\n          } catch (e) {\n            throw new FS.ErrnoError(29);\n          }\n        }\n      },\n      createLazyFile: function createLazyFile(parent, name, url, canRead, canWrite) {\n        // Lazy chunked Uint8Array (implements get and length from Uint8Array).\n        // Actual getting is abstracted away for eventual reuse.\n        var LazyUint8Array = /*#__PURE__*/function () {\n          function LazyUint8Array() {\n            _classCallCheck(this, LazyUint8Array);\n            this.lengthKnown = false;\n            this.chunks = []; // Loaded chunks. Index is the chunk number\n          }\n          return _createClass(LazyUint8Array, [{\n            key: \"get\",\n            value: function get(idx) {\n              if (idx > this.length - 1 || idx < 0) {\n                return undefined;\n              }\n              var chunkOffset = idx % this.chunkSize;\n              var chunkNum = idx / this.chunkSize | 0;\n              return this.getter(chunkNum)[chunkOffset];\n            }\n          }, {\n            key: \"setDataGetter\",\n            value: function setDataGetter(getter) {\n              this.getter = getter;\n            }\n          }, {\n            key: \"cacheLength\",\n            value: function cacheLength() {\n              // Find length\n              var xhr = new XMLHttpRequest();\n              xhr.open('HEAD', url, false);\n              xhr.send(null);\n              if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n              var datalength = Number(xhr.getResponseHeader(\"Content-length\"));\n              var header;\n              var hasByteServing = (header = xhr.getResponseHeader(\"Accept-Ranges\")) && header === \"bytes\";\n              var usesGzip = (header = xhr.getResponseHeader(\"Content-Encoding\")) && header === \"gzip\";\n              var chunkSize = 1024 * 1024; // Chunk size in bytes\n\n              if (!hasByteServing) chunkSize = datalength;\n\n              // Function to get a range from the remote URL.\n              var doXHR = function doXHR(from, to) {\n                if (from > to) throw new Error(\"invalid range (\" + from + \", \" + to + \") or no bytes requested!\");\n                if (to > datalength - 1) throw new Error(\"only \" + datalength + \" bytes available! programmer error!\");\n\n                // TODO: Use mozResponseArrayBuffer, responseStream, etc. if available.\n                var xhr = new XMLHttpRequest();\n                xhr.open('GET', url, false);\n                if (datalength !== chunkSize) xhr.setRequestHeader(\"Range\", \"bytes=\" + from + \"-\" + to);\n\n                // Some hints to the browser that we want binary data.\n                xhr.responseType = 'arraybuffer';\n                if (xhr.overrideMimeType) {\n                  xhr.overrideMimeType('text/plain; charset=x-user-defined');\n                }\n                xhr.send(null);\n                if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error(\"Couldn't load \" + url + \". Status: \" + xhr.status);\n                if (xhr.response !== undefined) {\n                  return new Uint8Array( /** @type{Array<number>} */xhr.response || []);\n                }\n                return intArrayFromString(xhr.responseText || '', true);\n              };\n              var lazyArray = this;\n              lazyArray.setDataGetter(function (chunkNum) {\n                var start = chunkNum * chunkSize;\n                var end = (chunkNum + 1) * chunkSize - 1; // including this byte\n                end = Math.min(end, datalength - 1); // if datalength-1 is selected, this is the last block\n                if (typeof lazyArray.chunks[chunkNum] == 'undefined') {\n                  lazyArray.chunks[chunkNum] = doXHR(start, end);\n                }\n                if (typeof lazyArray.chunks[chunkNum] == 'undefined') throw new Error('doXHR failed!');\n                return lazyArray.chunks[chunkNum];\n              });\n              if (usesGzip || !datalength) {\n                // if the server uses gzip or doesn't supply the length, we have to download the whole file to get the (uncompressed) length\n                chunkSize = datalength = 1; // this will force getter(0)/doXHR do download the whole file\n                datalength = this.getter(0).length;\n                chunkSize = datalength;\n                out(\"LazyFiles on gzip forces download of the whole file when length is accessed\");\n              }\n              this._length = datalength;\n              this._chunkSize = chunkSize;\n              this.lengthKnown = true;\n            }\n          }, {\n            key: \"length\",\n            get: function get() {\n              if (!this.lengthKnown) {\n                this.cacheLength();\n              }\n              return this._length;\n            }\n          }, {\n            key: \"chunkSize\",\n            get: function get() {\n              if (!this.lengthKnown) {\n                this.cacheLength();\n              }\n              return this._chunkSize;\n            }\n          }]);\n        }();\n        if (typeof XMLHttpRequest != 'undefined') {\n          if (!ENVIRONMENT_IS_WORKER) throw 'Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc';\n          var lazyArray = new LazyUint8Array();\n          var properties = {\n            isDevice: false,\n            contents: lazyArray\n          };\n        } else {\n          var properties = {\n            isDevice: false,\n            url: url\n          };\n        }\n        var node = FS.createFile(parent, name, properties, canRead, canWrite);\n        // This is a total hack, but I want to get this lazy file code out of the\n        // core of MEMFS. If we want to keep this lazy file concept I feel it should\n        // be its own thin LAZYFS proxying calls to MEMFS.\n        if (properties.contents) {\n          node.contents = properties.contents;\n        } else if (properties.url) {\n          node.contents = null;\n          node.url = properties.url;\n        }\n        // Add a function that defers querying the file size until it is asked the first time.\n        Object.defineProperties(node, {\n          usedBytes: {\n            get: function get() {\n              return this.contents.length;\n            }\n          }\n        });\n        // override each stream op with one that tries to force load the lazy file first\n        var stream_ops = {};\n        var keys = Object.keys(node.stream_ops);\n        keys.forEach(function (key) {\n          var fn = node.stream_ops[key];\n          stream_ops[key] = function () {\n            FS.forceLoadFile(node);\n            return fn.apply(void 0, arguments);\n          };\n        });\n        function writeChunks(stream, buffer, offset, length, position) {\n          var contents = stream.node.contents;\n          if (position >= contents.length) return 0;\n          var size = Math.min(contents.length - position, length);\n          if (contents.slice) {\n            // normal array\n            for (var i = 0; i < size; i++) {\n              buffer[offset + i] = contents[position + i];\n            }\n          } else {\n            for (var i = 0; i < size; i++) {\n              // LazyUint8Array from sync binary XHR\n              buffer[offset + i] = contents.get(position + i);\n            }\n          }\n          return size;\n        }\n        // use a custom read function\n        stream_ops.read = function (stream, buffer, offset, length, position) {\n          FS.forceLoadFile(node);\n          return writeChunks(stream, buffer, offset, length, position);\n        };\n        // use a custom mmap function\n        stream_ops.mmap = function (stream, length, position, prot, flags) {\n          FS.forceLoadFile(node);\n          var ptr = mmapAlloc(length);\n          if (!ptr) {\n            throw new FS.ErrnoError(48);\n          }\n          writeChunks(stream, HEAP8, ptr, length, position);\n          return {\n            ptr: ptr,\n            allocated: true\n          };\n        };\n        node.stream_ops = stream_ops;\n        return node;\n      }\n    };\n\n    /**\n     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the\n     * emscripten HEAP, returns a copy of that string as a Javascript String object.\n     *\n     * @param {number} ptr\n     * @param {number=} maxBytesToRead - An optional length that specifies the\n     *   maximum number of bytes to read. You can omit this parameter to scan the\n     *   string until the first 0 byte. If maxBytesToRead is passed, and the string\n     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the\n     *   string will cut short at that byte index (i.e. maxBytesToRead will not\n     *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing\n     *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw\n     *   JS JIT optimizations off, so it is worth to consider consistently using one\n     * @return {string}\n     */\n    var UTF8ToString = function UTF8ToString(ptr, maxBytesToRead) {\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\n    };\n    var SYSCALLS = {\n      DEFAULT_POLLMASK: 5,\n      calculateAt: function calculateAt(dirfd, path, allowEmpty) {\n        if (PATH.isAbs(path)) {\n          return path;\n        }\n        // relative path\n        var dir;\n        if (dirfd === -100) {\n          dir = FS.cwd();\n        } else {\n          var dirstream = SYSCALLS.getStreamFromFD(dirfd);\n          dir = dirstream.path;\n        }\n        if (path.length == 0) {\n          if (!allowEmpty) {\n            throw new FS.ErrnoError(44);\n            ;\n          }\n          return dir;\n        }\n        return PATH.join2(dir, path);\n      },\n      doStat: function doStat(func, path, buf) {\n        var stat = func(path);\n        HEAP32[buf >> 2] = stat.dev;\n        HEAP32[buf + 4 >> 2] = stat.mode;\n        HEAPU32[buf + 8 >> 2] = stat.nlink;\n        HEAP32[buf + 12 >> 2] = stat.uid;\n        HEAP32[buf + 16 >> 2] = stat.gid;\n        HEAP32[buf + 20 >> 2] = stat.rdev;\n        tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1.0 ? tempDouble > 0.0 ? +Math.floor(tempDouble / 4294967296.0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0 : 0)], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];\n        HEAP32[buf + 32 >> 2] = 4096;\n        HEAP32[buf + 36 >> 2] = stat.blocks;\n        var atime = stat.atime.getTime();\n        var mtime = stat.mtime.getTime();\n        var ctime = stat.ctime.getTime();\n        tempI64 = [Math.floor(atime / 1000) >>> 0, (tempDouble = Math.floor(atime / 1000), +Math.abs(tempDouble) >= 1.0 ? tempDouble > 0.0 ? +Math.floor(tempDouble / 4294967296.0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];\n        HEAPU32[buf + 48 >> 2] = atime % 1000 * 1000;\n        tempI64 = [Math.floor(mtime / 1000) >>> 0, (tempDouble = Math.floor(mtime / 1000), +Math.abs(tempDouble) >= 1.0 ? tempDouble > 0.0 ? +Math.floor(tempDouble / 4294967296.0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0 : 0)], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];\n        HEAPU32[buf + 64 >> 2] = mtime % 1000 * 1000;\n        tempI64 = [Math.floor(ctime / 1000) >>> 0, (tempDouble = Math.floor(ctime / 1000), +Math.abs(tempDouble) >= 1.0 ? tempDouble > 0.0 ? +Math.floor(tempDouble / 4294967296.0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0 : 0)], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];\n        HEAPU32[buf + 80 >> 2] = ctime % 1000 * 1000;\n        tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1.0 ? tempDouble > 0.0 ? +Math.floor(tempDouble / 4294967296.0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0 : 0)], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];\n        return 0;\n      },\n      doMsync: function doMsync(addr, stream, len, flags, offset) {\n        if (!FS.isFile(stream.node.mode)) {\n          throw new FS.ErrnoError(43);\n        }\n        if (flags & 2) {\n          // MAP_PRIVATE calls need not to be synced back to underlying fs\n          return 0;\n        }\n        var buffer = HEAPU8.slice(addr, addr + len);\n        FS.msync(stream, buffer, offset, len, flags);\n      },\n      getStreamFromFD: function getStreamFromFD(fd) {\n        var stream = FS.getStreamChecked(fd);\n        return stream;\n      },\n      varargs: undefined,\n      getStr: function getStr(ptr) {\n        var ret = UTF8ToString(ptr);\n        return ret;\n      }\n    };\n    function ___syscall_fcntl64(fd, cmd, varargs) {\n      SYSCALLS.varargs = varargs;\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        switch (cmd) {\n          case 0:\n            {\n              var arg = syscallGetVarargI();\n              if (arg < 0) {\n                return -28;\n              }\n              while (FS.streams[arg]) {\n                arg++;\n              }\n              var newStream;\n              newStream = FS.dupStream(stream, arg);\n              return newStream.fd;\n            }\n          case 1:\n          case 2:\n            return 0;\n          // FD_CLOEXEC makes no sense for a single process.\n          case 3:\n            return stream.flags;\n          case 4:\n            {\n              var arg = syscallGetVarargI();\n              stream.flags |= arg;\n              return 0;\n            }\n          case 12:\n            {\n              var arg = syscallGetVarargP();\n              var offset = 0;\n              // We're always unlocked.\n              HEAP16[arg + offset >> 1] = 2;\n              return 0;\n            }\n          case 13:\n          case 14:\n            return 0;\n          // Pretend that the locking is successful.\n        }\n        return -28;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n    function ___syscall_ioctl(fd, op, varargs) {\n      SYSCALLS.varargs = varargs;\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        switch (op) {\n          case 21509:\n            {\n              if (!stream.tty) return -59;\n              return 0;\n            }\n          case 21505:\n            {\n              if (!stream.tty) return -59;\n              if (stream.tty.ops.ioctl_tcgets) {\n                var termios = stream.tty.ops.ioctl_tcgets(stream);\n                var argp = syscallGetVarargP();\n                HEAP32[argp >> 2] = termios.c_iflag || 0;\n                HEAP32[argp + 4 >> 2] = termios.c_oflag || 0;\n                HEAP32[argp + 8 >> 2] = termios.c_cflag || 0;\n                HEAP32[argp + 12 >> 2] = termios.c_lflag || 0;\n                for (var i = 0; i < 32; i++) {\n                  HEAP8[argp + i + 17] = termios.c_cc[i] || 0;\n                }\n                return 0;\n              }\n              return 0;\n            }\n          case 21510:\n          case 21511:\n          case 21512:\n            {\n              if (!stream.tty) return -59;\n              return 0; // no-op, not actually adjusting terminal settings\n            }\n          case 21506:\n          case 21507:\n          case 21508:\n            {\n              if (!stream.tty) return -59;\n              if (stream.tty.ops.ioctl_tcsets) {\n                var argp = syscallGetVarargP();\n                var c_iflag = HEAP32[argp >> 2];\n                var c_oflag = HEAP32[argp + 4 >> 2];\n                var c_cflag = HEAP32[argp + 8 >> 2];\n                var c_lflag = HEAP32[argp + 12 >> 2];\n                var c_cc = [];\n                for (var i = 0; i < 32; i++) {\n                  c_cc.push(HEAP8[argp + i + 17]);\n                }\n                return stream.tty.ops.ioctl_tcsets(stream.tty, op, {\n                  c_iflag: c_iflag,\n                  c_oflag: c_oflag,\n                  c_cflag: c_cflag,\n                  c_lflag: c_lflag,\n                  c_cc: c_cc\n                });\n              }\n              return 0; // no-op, not actually adjusting terminal settings\n            }\n          case 21519:\n            {\n              if (!stream.tty) return -59;\n              var argp = syscallGetVarargP();\n              HEAP32[argp >> 2] = 0;\n              return 0;\n            }\n          case 21520:\n            {\n              if (!stream.tty) return -59;\n              return -28; // not supported\n            }\n          case 21531:\n            {\n              var argp = syscallGetVarargP();\n              return FS.ioctl(stream, op, argp);\n            }\n          case 21523:\n            {\n              // TODO: in theory we should write to the winsize struct that gets\n              // passed in, but for now musl doesn't read anything on it\n              if (!stream.tty) return -59;\n              if (stream.tty.ops.ioctl_tiocgwinsz) {\n                var winsize = stream.tty.ops.ioctl_tiocgwinsz(stream.tty);\n                var argp = syscallGetVarargP();\n                HEAP16[argp >> 1] = winsize[0];\n                HEAP16[argp + 2 >> 1] = winsize[1];\n              }\n              return 0;\n            }\n          case 21524:\n            {\n              // TODO: technically, this ioctl call should change the window size.\n              // but, since emscripten doesn't have any concept of a terminal window\n              // yet, we'll just silently throw it away as we do TIOCGWINSZ\n              if (!stream.tty) return -59;\n              return 0;\n            }\n          case 21515:\n            {\n              if (!stream.tty) return -59;\n              return 0;\n            }\n          default:\n            return -28;\n          // not supported\n        }\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n    function ___syscall_openat(dirfd, path, flags, varargs) {\n      SYSCALLS.varargs = varargs;\n      try {\n        path = SYSCALLS.getStr(path);\n        path = SYSCALLS.calculateAt(dirfd, path);\n        var mode = varargs ? syscallGetVarargI() : 0;\n        return FS.open(path, flags, mode).fd;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return -e.errno;\n      }\n    }\n    var __abort_js = function __abort_js() {\n      abort('');\n    };\n    var __emscripten_memcpy_js = function __emscripten_memcpy_js(dest, src, num) {\n      return HEAPU8.copyWithin(dest, src, src + num);\n    };\n    var stringToUTF8 = function stringToUTF8(str, outPtr, maxBytesToWrite) {\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n    };\n    var __tzset_js = function __tzset_js(timezone, daylight, std_name, dst_name) {\n      // TODO: Use (malleable) environment variables instead of system settings.\n      var currentYear = new Date().getFullYear();\n      var winter = new Date(currentYear, 0, 1);\n      var summer = new Date(currentYear, 6, 1);\n      var winterOffset = winter.getTimezoneOffset();\n      var summerOffset = summer.getTimezoneOffset();\n\n      // Local standard timezone offset. Local standard time is not adjusted for\n      // daylight savings.  This code uses the fact that getTimezoneOffset returns\n      // a greater value during Standard Time versus Daylight Saving Time (DST).\n      // Thus it determines the expected output during Standard Time, and it\n      // compares whether the output of the given date the same (Standard) or less\n      // (DST).\n      var stdTimezoneOffset = Math.max(winterOffset, summerOffset);\n\n      // timezone is specified as seconds west of UTC (\"The external variable\n      // `timezone` shall be set to the difference, in seconds, between\n      // Coordinated Universal Time (UTC) and local standard time.\"), the same\n      // as returned by stdTimezoneOffset.\n      // See http://pubs.opengroup.org/onlinepubs/009695399/functions/tzset.html\n      HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;\n      HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);\n      var extractZone = function extractZone(timezoneOffset) {\n        // Why inverse sign?\n        // Read here https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/getTimezoneOffset\n        var sign = timezoneOffset >= 0 ? \"-\" : \"+\";\n        var absOffset = Math.abs(timezoneOffset);\n        var hours = String(Math.floor(absOffset / 60)).padStart(2, \"0\");\n        var minutes = String(absOffset % 60).padStart(2, \"0\");\n        return \"UTC\".concat(sign).concat(hours).concat(minutes);\n      };\n      var winterName = extractZone(winterOffset);\n      var summerName = extractZone(summerOffset);\n      if (summerOffset < winterOffset) {\n        // Northern hemisphere\n        stringToUTF8(winterName, std_name, 17);\n        stringToUTF8(summerName, dst_name, 17);\n      } else {\n        stringToUTF8(winterName, dst_name, 17);\n        stringToUTF8(summerName, std_name, 17);\n      }\n    };\n    var getHeapMax = function getHeapMax() {\n      return HEAPU8.length;\n    };\n    var abortOnCannotGrowMemory = function abortOnCannotGrowMemory(requestedSize) {\n      abort('OOM');\n    };\n    var _emscripten_resize_heap = function _emscripten_resize_heap(requestedSize) {\n      var oldSize = HEAPU8.length;\n      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\n      requestedSize >>>= 0;\n      abortOnCannotGrowMemory(requestedSize);\n    };\n    var ENV = {};\n    var getExecutableName = function getExecutableName() {\n      return thisProgram || './this.program';\n    };\n    var getEnvStrings = function getEnvStrings() {\n      if (!getEnvStrings.strings) {\n        // Default values.\n        // Browser language detection #8751\n        var lang = ((typeof navigator === \"undefined\" ? \"undefined\" : _typeof(navigator)) == 'object' && navigator.languages && navigator.languages[0] || 'C').replace('-', '_') + '.UTF-8';\n        var env = {\n          'USER': 'web_user',\n          'LOGNAME': 'web_user',\n          'PATH': '/',\n          'PWD': '/',\n          'HOME': '/home/web_user',\n          'LANG': lang,\n          '_': getExecutableName()\n        };\n        // Apply the user-provided values, if any.\n        for (var x in ENV) {\n          // x is a key in ENV; if ENV[x] is undefined, that means it was\n          // explicitly set to be so. We allow user code to do that to\n          // force variables with default values to remain unset.\n          if (ENV[x] === undefined) delete env[x];else env[x] = ENV[x];\n        }\n        var strings = [];\n        for (var x in env) {\n          strings.push(\"\".concat(x, \"=\").concat(env[x]));\n        }\n        getEnvStrings.strings = strings;\n      }\n      return getEnvStrings.strings;\n    };\n    var stringToAscii = function stringToAscii(str, buffer) {\n      for (var i = 0; i < str.length; ++i) {\n        HEAP8[buffer++] = str.charCodeAt(i);\n      }\n      // Null-terminate the string\n      HEAP8[buffer] = 0;\n    };\n    var _environ_get = function _environ_get(__environ, environ_buf) {\n      var bufSize = 0;\n      getEnvStrings().forEach(function (string, i) {\n        var ptr = environ_buf + bufSize;\n        HEAPU32[__environ + i * 4 >> 2] = ptr;\n        stringToAscii(string, ptr);\n        bufSize += string.length + 1;\n      });\n      return 0;\n    };\n    var _environ_sizes_get = function _environ_sizes_get(penviron_count, penviron_buf_size) {\n      var strings = getEnvStrings();\n      HEAPU32[penviron_count >> 2] = strings.length;\n      var bufSize = 0;\n      strings.forEach(function (string) {\n        return bufSize += string.length + 1;\n      });\n      HEAPU32[penviron_buf_size >> 2] = bufSize;\n      return 0;\n    };\n    function _fd_close(fd) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        FS.close(stream);\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return e.errno;\n      }\n    }\n\n    /** @param {number=} offset */\n    var doReadv = function doReadv(stream, iov, iovcnt, offset) {\n      var ret = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAPU32[iov >> 2];\n        var len = HEAPU32[iov + 4 >> 2];\n        iov += 8;\n        var curr = FS.read(stream, HEAP8, ptr, len, offset);\n        if (curr < 0) return -1;\n        ret += curr;\n        if (curr < len) break; // nothing more to read\n        if (typeof offset != 'undefined') {\n          offset += curr;\n        }\n      }\n      return ret;\n    };\n    function _fd_read(fd, iov, iovcnt, pnum) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var num = doReadv(stream, iov, iovcnt);\n        HEAPU32[pnum >> 2] = num;\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return e.errno;\n      }\n    }\n    var convertI32PairToI53Checked = function convertI32PairToI53Checked(lo, hi) {\n      return hi + 0x200000 >>> 0 < 0x400001 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;\n    };\n    function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {\n      var offset = convertI32PairToI53Checked(offset_low, offset_high);\n      try {\n        if (isNaN(offset)) return 61;\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        FS.llseek(stream, offset, whence);\n        tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1.0 ? tempDouble > 0.0 ? +Math.floor(tempDouble / 4294967296.0) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296.0) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];\n        if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null; // reset readdir state\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return e.errno;\n      }\n      ;\n    }\n\n    /** @param {number=} offset */\n    var doWritev = function doWritev(stream, iov, iovcnt, offset) {\n      var ret = 0;\n      for (var i = 0; i < iovcnt; i++) {\n        var ptr = HEAPU32[iov >> 2];\n        var len = HEAPU32[iov + 4 >> 2];\n        iov += 8;\n        var curr = FS.write(stream, HEAP8, ptr, len, offset);\n        if (curr < 0) return -1;\n        ret += curr;\n        if (typeof offset != 'undefined') {\n          offset += curr;\n        }\n      }\n      return ret;\n    };\n    function _fd_write(fd, iov, iovcnt, pnum) {\n      try {\n        var stream = SYSCALLS.getStreamFromFD(fd);\n        var num = doWritev(stream, iov, iovcnt);\n        HEAPU32[pnum >> 2] = num;\n        return 0;\n      } catch (e) {\n        if (typeof FS == 'undefined' || !(e.name === 'ErrnoError')) throw e;\n        return e.errno;\n      }\n    }\n    var getCFunc = function getCFunc(ident) {\n      var func = Module['_' + ident]; // closure exported function\n      return func;\n    };\n    var writeArrayToMemory = function writeArrayToMemory(array, buffer) {\n      HEAP8.set(array, buffer);\n    };\n    var stackAlloc = function stackAlloc(sz) {\n      return _emscripten_stack_alloc(sz);\n    };\n    var stringToUTF8OnStack = function stringToUTF8OnStack(str) {\n      var size = lengthBytesUTF8(str) + 1;\n      var ret = stackAlloc(size);\n      stringToUTF8(str, ret, size);\n      return ret;\n    };\n\n    /**\n     * @param {string|null=} returnType\n     * @param {Array=} argTypes\n     * @param {Arguments|Array=} args\n     * @param {Object=} opts\n     */\n    var ccall = function ccall(ident, returnType, argTypes, args, opts) {\n      // For fast lookup of conversion functions\n      var toC = {\n        'string': function string(str) {\n          var ret = 0;\n          if (str !== null && str !== undefined && str !== 0) {\n            // null string\n            // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\n            ret = stringToUTF8OnStack(str);\n          }\n          return ret;\n        },\n        'array': function array(arr) {\n          var ret = stackAlloc(arr.length);\n          writeArrayToMemory(arr, ret);\n          return ret;\n        }\n      };\n      function convertReturnValue(ret) {\n        if (returnType === 'string') {\n          return UTF8ToString(ret);\n        }\n        if (returnType === 'boolean') return Boolean(ret);\n        return ret;\n      }\n      var func = getCFunc(ident);\n      var cArgs = [];\n      var stack = 0;\n      if (args) {\n        for (var i = 0; i < args.length; i++) {\n          var converter = toC[argTypes[i]];\n          if (converter) {\n            if (stack === 0) stack = stackSave();\n            cArgs[i] = converter(args[i]);\n          } else {\n            cArgs[i] = args[i];\n          }\n        }\n      }\n      var ret = func.apply(void 0, cArgs);\n      function onDone(ret) {\n        if (stack !== 0) stackRestore(stack);\n        return convertReturnValue(ret);\n      }\n      ret = onDone(ret);\n      return ret;\n    };\n\n    /**\n     * @param {string=} returnType\n     * @param {Array=} argTypes\n     * @param {Object=} opts\n     */\n    var cwrap = function cwrap(ident, returnType, argTypes, opts) {\n      // When the function takes numbers and returns a number, we can just return\n      // the original function\n      var numericArgs = !argTypes || argTypes.every(function (type) {\n        return type === 'number' || type === 'boolean';\n      });\n      var numericRet = returnType !== 'string';\n      if (numericRet && numericArgs && !opts) {\n        return getCFunc(ident);\n      }\n      return function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n        return ccall(ident, returnType, argTypes, args, opts);\n      };\n    };\n    var ALLOC_NORMAL = 0;\n    function intArrayToString(array) {\n      var ret = [];\n      for (var i = 0; i < array.length; i++) {\n        var chr = array[i];\n        if (chr > 0xFF) {\n          chr &= 0xFF;\n        }\n        ret.push(String.fromCharCode(chr));\n      }\n      return ret.join('');\n    }\n    FS.createPreloadedFile = FS_createPreloadedFile;\n    FS.staticInit();\n    ;\n    var wasmImports = {\n      /** @export */\n      __cxa_throw: ___cxa_throw,\n      /** @export */\n      __syscall_fcntl64: ___syscall_fcntl64,\n      /** @export */\n      __syscall_ioctl: ___syscall_ioctl,\n      /** @export */\n      __syscall_openat: ___syscall_openat,\n      /** @export */\n      _abort_js: __abort_js,\n      /** @export */\n      _emscripten_memcpy_js: __emscripten_memcpy_js,\n      /** @export */\n      _tzset_js: __tzset_js,\n      /** @export */\n      emscripten_resize_heap: _emscripten_resize_heap,\n      /** @export */\n      environ_get: _environ_get,\n      /** @export */\n      environ_sizes_get: _environ_sizes_get,\n      /** @export */\n      fd_close: _fd_close,\n      /** @export */\n      fd_read: _fd_read,\n      /** @export */\n      fd_seek: _fd_seek,\n      /** @export */\n      fd_write: _fd_write\n    };\n    var wasmExports = createWasm();\n    var _wasm_call_ctors = function ___wasm_call_ctors() {\n      return (_wasm_call_ctors = wasmExports['__wasm_call_ctors'])();\n    };\n    var _dijkstra_from_file = Module['_dijkstra_from_file'] = function (a0, a1, a2, a3) {\n      return (_dijkstra_from_file = Module['_dijkstra_from_file'] = wasmExports['dijkstra_from_file'])(a0, a1, a2, a3);\n    };\n    var _emscripten_stack_restore = function __emscripten_stack_restore(a0) {\n      return (_emscripten_stack_restore = wasmExports['_emscripten_stack_restore'])(a0);\n    };\n    var _emscripten_stack_alloc = function __emscripten_stack_alloc(a0) {\n      return (_emscripten_stack_alloc = wasmExports['_emscripten_stack_alloc'])(a0);\n    };\n    var _emscripten_stack_get_current2 = function _emscripten_stack_get_current() {\n      return (_emscripten_stack_get_current2 = wasmExports['emscripten_stack_get_current'])();\n    };\n    var _cxa_is_pointer_type = function ___cxa_is_pointer_type(a0) {\n      return (_cxa_is_pointer_type = wasmExports['__cxa_is_pointer_type'])(a0);\n    };\n    var dynCall_jiji = Module['dynCall_jiji'] = function (a0, a1, a2, a3, a4) {\n      return (dynCall_jiji = Module['dynCall_jiji'] = wasmExports['dynCall_jiji'])(a0, a1, a2, a3, a4);\n    };\n    var dynCall_viijii = Module['dynCall_viijii'] = function (a0, a1, a2, a3, a4, a5, a6) {\n      return (dynCall_viijii = Module['dynCall_viijii'] = wasmExports['dynCall_viijii'])(a0, a1, a2, a3, a4, a5, a6);\n    };\n    var dynCall_iiiiij = Module['dynCall_iiiiij'] = function (a0, a1, a2, a3, a4, a5, a6) {\n      return (dynCall_iiiiij = Module['dynCall_iiiiij'] = wasmExports['dynCall_iiiiij'])(a0, a1, a2, a3, a4, a5, a6);\n    };\n    var dynCall_iiiiijj = Module['dynCall_iiiiijj'] = function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {\n      return (dynCall_iiiiijj = Module['dynCall_iiiiijj'] = wasmExports['dynCall_iiiiijj'])(a0, a1, a2, a3, a4, a5, a6, a7, a8);\n    };\n    var dynCall_iiiiiijj = Module['dynCall_iiiiiijj'] = function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {\n      return (dynCall_iiiiiijj = Module['dynCall_iiiiiijj'] = wasmExports['dynCall_iiiiiijj'])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);\n    };\n\n    // include: postamble.js\n    // === Auto-generated postamble setup entry stuff ===\n\n    Module['ccall'] = ccall;\n    Module['cwrap'] = cwrap;\n    Module['intArrayFromString'] = intArrayFromString;\n    Module['intArrayToString'] = intArrayToString;\n    Module['FS'] = FS;\n    Module['ALLOC_NORMAL'] = ALLOC_NORMAL;\n    var calledRun;\n    dependenciesFulfilled = function runCaller() {\n      // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n      if (!calledRun) run();\n      if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n    };\n    function run() {\n      if (runDependencies > 0) {\n        return;\n      }\n      preRun();\n\n      // a preRun added a dependency, run will be called later\n      if (runDependencies > 0) {\n        return;\n      }\n      function doRun() {\n        var _Module$onRuntimeInit;\n        // run may have just been called through dependencies being fulfilled just in this very frame,\n        // or while the async setStatus time below was happening\n        if (calledRun) return;\n        calledRun = true;\n        Module['calledRun'] = true;\n        if (ABORT) return;\n        initRuntime();\n        readyPromiseResolve(Module);\n        (_Module$onRuntimeInit = Module['onRuntimeInitialized']) === null || _Module$onRuntimeInit === void 0 || _Module$onRuntimeInit.call(Module);\n        postRun();\n      }\n      if (Module['setStatus']) {\n        Module['setStatus']('Running...');\n        setTimeout(function () {\n          setTimeout(function () {\n            Module['setStatus']('');\n          }, 1);\n          doRun();\n        }, 1);\n      } else {\n        doRun();\n      }\n    }\n    if (Module['preInit']) {\n      if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\n      while (Module['preInit'].length > 0) {\n        Module['preInit'].pop()();\n      }\n    }\n    run();\n\n    // end include: postamble.js\n\n    // include: postamble_modularize.js\n    // In MODULARIZE mode we wrap the generated code in a factory function\n    // and return either the Module itself, or a promise of the module.\n    //\n    // We assign to the `moduleRtn` global here and configure closure to see\n    // this as and extern so it won't get minified.\n\n    moduleRtn = readyPromise;\n\n    // end include: postamble_modularize.js\n\n    return moduleRtn;\n  };\n}();\nif (( false ? 0 : _typeof(exports)) === 'object' && ( false ? 0 : _typeof(module)) === 'object') module.exports = Module;else if (true) !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {\n  return Module;\n}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\n//# sourceURL=webpack://mapapp/./pj/static/C++/dijkstra.js?");

/***/ })

}]);