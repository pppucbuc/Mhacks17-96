/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunkmapapp"] = self["webpackChunkmapapp"] || []).push([["pj_static_C_add_js"],{

/***/ "./pj/static/C++/add.js":
/*!******************************!*\
  !*** ./pj/static/C++/add.js ***!
  \******************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var __dirname = \"/\";\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\n// include: shell.js\n// The Module object: Our interface to the outside world. We import\n// and export values on it. There are various ways Module can be used:\n// 1. Not defined. We create it here\n// 2. A function parameter, function(moduleArg) => Promise<Module>\n// 3. pre-run appended it, var Module = {}; ..generated code..\n// 4. External script tag defines var Module.\n// We need to check if Module already exists (e.g. case 3 above).\n// Substitution will be replaced with actual code on later stage of the build,\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\n// Note that if you want to run closure, and also to use Module\n// after the generated code, you will need to define   var Module = {};\n// before the code. Then that object will be used in the code, and you\n// can continue to use Module afterwards as well.\nvar Module = typeof Module != 'undefined' ? Module : {};\n\n// Determine the runtime environment we are in. You can customize this by\n// setting the ENVIRONMENT setting at compile time (see settings.js).\n\n// Attempt to auto-detect the environment\nvar ENVIRONMENT_IS_WEB = (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) == 'object';\nvar ENVIRONMENT_IS_WORKER = typeof importScripts == 'function';\n// N.b. Electron.js environment is simultaneously a NODE-environment, but\n// also a web environment.\nvar ENVIRONMENT_IS_NODE = (typeof process === \"undefined\" ? \"undefined\" : _typeof(process)) == 'object' && _typeof(process.versions) == 'object' && typeof process.versions.node == 'string';\nvar ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\nif (Module['ENVIRONMENT']) {\n  throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)');\n}\nif (ENVIRONMENT_IS_NODE) {\n  // `require()` is no-op in an ESM module, use `createRequire()` to construct\n  // the require()` function.  This is only necessary for multi-environment\n  // builds, `-sENVIRONMENT=node` emits a static import declaration instead.\n  // TODO: Swap all `require()`'s with `import()`'s?\n}\n\n// --pre-jses are emitted after the Module integration code, so that they can\n// refer to Module (if they choose; they can also define Module)\n\n// Sometimes an existing Module object exists with properties\n// meant to overwrite the default module functionality. Here\n// we collect those properties and reapply _after_ we configure\n// the current environment's defaults to avoid having to be so\n// defensive during initialization.\nvar moduleOverrides = Object.assign({}, Module);\nvar arguments_ = [];\nvar thisProgram = './this.program';\nvar quit_ = function quit_(status, toThrow) {\n  throw toThrow;\n};\n\n// `/` should be present at the end if `scriptDirectory` is not empty\nvar scriptDirectory = '';\nfunction locateFile(path) {\n  if (Module['locateFile']) {\n    return Module['locateFile'](path, scriptDirectory);\n  }\n  return scriptDirectory + path;\n}\n\n// Hooks that are implemented differently in different runtime environments.\nvar readAsync, readBinary;\nif (ENVIRONMENT_IS_NODE) {\n  if (typeof process == 'undefined' || !process.release || process.release.name !== 'node') throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\n  var nodeVersion = process.versions.node;\n  var numericVersion = nodeVersion.split('.').slice(0, 3);\n  numericVersion = numericVersion[0] * 10000 + numericVersion[1] * 100 + numericVersion[2].split('-')[0] * 1;\n  var minVersion = 160000;\n  if (numericVersion < 160000) {\n    throw new Error('This emscripten-generated code requires node v16.0.0 (detected v' + nodeVersion + ')');\n  }\n\n  // These modules will usually be used on Node.js. Load them eagerly to avoid\n  // the complexity of lazy-loading.\n  var fs = __webpack_require__(/*! fs */ \"?e683\");\n  var nodePath = __webpack_require__(/*! path */ \"./node_modules/path/path.js\");\n  scriptDirectory = __dirname + '/';\n\n  // include: node_shell_read.js\n  readBinary = function readBinary(filename) {\n    // We need to re-wrap `file://` strings to URLs. Normalizing isn't\n    // necessary in that case, the path should already be absolute.\n    filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);\n    var ret = fs.readFileSync(filename);\n    assert(ret.buffer);\n    return ret;\n  };\n  readAsync = function readAsync(filename) {\n    var binary = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    // See the comment in the `readBinary` function.\n    filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);\n    return new Promise(function (resolve, reject) {\n      fs.readFile(filename, binary ? undefined : 'utf8', function (err, data) {\n        if (err) reject(err);else resolve(binary ? data.buffer : data);\n      });\n    });\n  };\n  // end include: node_shell_read.js\n  if (!Module['thisProgram'] && process.argv.length > 1) {\n    thisProgram = process.argv[1].replace(/\\\\/g, '/');\n  }\n  arguments_ = process.argv.slice(2);\n  if (true) {\n    module['exports'] = Module;\n  }\n  process.on('uncaughtException', function (ex) {\n    // suppress ExitStatus exceptions from showing an error\n    if (ex !== 'unwind' && !(ex instanceof ExitStatus) && !(ex.context instanceof ExitStatus)) {\n      throw ex;\n    }\n  });\n  quit_ = function quit_(status, toThrow) {\n    process.exitCode = status;\n    throw toThrow;\n  };\n} else if (ENVIRONMENT_IS_SHELL) {\n  if ((typeof process === \"undefined\" ? \"undefined\" : _typeof(process)) == 'object' && \"function\" === 'function' || (typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) == 'object' || typeof importScripts == 'function') throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\n} else\n  // Note that this includes Node.js workers when relevant (pthreads is enabled).\n  // Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\n  // ENVIRONMENT_IS_NODE.\n  if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\n    if (ENVIRONMENT_IS_WORKER) {\n      // Check worker, not web, since window could be polyfilled\n      scriptDirectory = self.location.href;\n    } else if (typeof document != 'undefined' && document.currentScript) {\n      // web\n      scriptDirectory = document.currentScript.src;\n    }\n    // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\n    // otherwise, slice off the final part of the url to find the script directory.\n    // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\n    // and scriptDirectory will correctly be replaced with an empty string.\n    // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),\n    // they are removed because they could contain a slash.\n    if (scriptDirectory.startsWith('blob:')) {\n      scriptDirectory = '';\n    } else {\n      scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/') + 1);\n    }\n    if (!((typeof window === \"undefined\" ? \"undefined\" : _typeof(window)) == 'object' || typeof importScripts == 'function')) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\n    {\n      // include: web_or_worker_shell_read.js\n      if (ENVIRONMENT_IS_WORKER) {\n        readBinary = function readBinary(url) {\n          var xhr = new XMLHttpRequest();\n          xhr.open('GET', url, false);\n          xhr.responseType = 'arraybuffer';\n          xhr.send(null);\n          return new Uint8Array( /** @type{!ArrayBuffer} */xhr.response);\n        };\n      }\n      readAsync = function readAsync(url) {\n        // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.\n        // See https://github.com/github/fetch/pull/92#issuecomment-140665932\n        // Cordova or Electron apps are typically loaded from a file:// url.\n        // So use XHR on webview if URL is a file URL.\n        if (isFileURI(url)) {\n          return new Promise(function (reject, resolve) {\n            var xhr = new XMLHttpRequest();\n            xhr.open('GET', url, true);\n            xhr.responseType = 'arraybuffer';\n            xhr.onload = function () {\n              if (xhr.status == 200 || xhr.status == 0 && xhr.response) {\n                // file URLs can return 0\n                resolve(xhr.response);\n              }\n              reject(xhr.status);\n            };\n            xhr.onerror = reject;\n            xhr.send(null);\n          });\n        }\n        return fetch(url, {\n          credentials: 'same-origin'\n        }).then(function (response) {\n          if (response.ok) {\n            return response.arrayBuffer();\n          }\n          return Promise.reject(new Error(response.status + ' : ' + response.url));\n        });\n      };\n      // end include: web_or_worker_shell_read.js\n    }\n  } else {\n    throw new Error('environment detection error');\n  }\nvar out = Module['print'] || console.log.bind(console);\nvar err = Module['printErr'] || console.error.bind(console);\n\n// Merge back in the overrides\nObject.assign(Module, moduleOverrides);\n// Free the object hierarchy contained in the overrides, this lets the GC\n// reclaim data used.\nmoduleOverrides = null;\ncheckIncomingModuleAPI();\n\n// Emit code to handle expected values on the Module object. This applies Module.x\n// to the proper local x. This has two benefits: first, we only emit it if it is\n// expected to arrive, and second, by using a local everywhere else that can be\n// minified.\n\nif (Module['arguments']) arguments_ = Module['arguments'];\nlegacyModuleProp('arguments', 'arguments_');\nif (Module['thisProgram']) thisProgram = Module['thisProgram'];\nlegacyModuleProp('thisProgram', 'thisProgram');\nif (Module['quit']) quit_ = Module['quit'];\nlegacyModuleProp('quit', 'quit_');\n\n// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\n// Assertions on removed incoming Module JS APIs.\nassert(typeof Module['memoryInitializerPrefixURL'] == 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['pthreadMainPrefixURL'] == 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['cdInitializerPrefixURL'] == 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['filePackagePrefixURL'] == 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');\nassert(typeof Module['read'] == 'undefined', 'Module.read option was removed');\nassert(typeof Module['readAsync'] == 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');\nassert(typeof Module['readBinary'] == 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');\nassert(typeof Module['setWindowTitle'] == 'undefined', 'Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)');\nassert(typeof Module['TOTAL_MEMORY'] == 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');\nlegacyModuleProp('asm', 'wasmExports');\nlegacyModuleProp('readAsync', 'readAsync');\nlegacyModuleProp('readBinary', 'readBinary');\nlegacyModuleProp('setWindowTitle', 'setWindowTitle');\nvar IDBFS = 'IDBFS is no longer included by default; build with -lidbfs.js';\nvar PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';\nvar WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';\nvar FETCHFS = 'FETCHFS is no longer included by default; build with -lfetchfs.js';\nvar ICASEFS = 'ICASEFS is no longer included by default; build with -licasefs.js';\nvar JSFILEFS = 'JSFILEFS is no longer included by default; build with -ljsfilefs.js';\nvar OPFS = 'OPFS is no longer included by default; build with -lopfs.js';\nvar NODEFS = 'NODEFS is no longer included by default; build with -lnodefs.js';\nassert(!ENVIRONMENT_IS_SHELL, 'shell environment detected but not enabled at build time.  Add `shell` to `-sENVIRONMENT` to enable.');\n\n// end include: shell.js\n\n// include: preamble.js\n// === Preamble library stuff ===\n\n// Documentation for the public APIs defined in this file must be updated in:\n//    site/source/docs/api_reference/preamble.js.rst\n// A prebuilt local version of the documentation is available at:\n//    site/build/text/docs/api_reference/preamble.js.txt\n// You can also build docs locally as HTML or other formats in site/\n// An online HTML version (which may be of a different version of Emscripten)\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\n\nvar wasmBinary;\nif (Module['wasmBinary']) wasmBinary = Module['wasmBinary'];\nlegacyModuleProp('wasmBinary', 'wasmBinary');\nif ((typeof WebAssembly === \"undefined\" ? \"undefined\" : _typeof(WebAssembly)) != 'object') {\n  err('no native wasm support detected');\n}\n\n// Wasm globals\n\nvar wasmMemory;\n\n//========================================\n// Runtime essentials\n//========================================\n\n// whether we are quitting the application. no code should run after this.\n// set in exit() and abort()\nvar ABORT = false;\n\n// set by exit() and abort().  Passed to 'onExit' handler.\n// NOTE: This is also used as the process return code code in shell environments\n// but only when noExitRuntime is false.\nvar EXITSTATUS;\n\n// In STRICT mode, we only define assert() when ASSERTIONS is set.  i.e. we\n// don't define it at all in release modes.  This matches the behaviour of\n// MINIMAL_RUNTIME.\n// TODO(sbc): Make this the default even without STRICT enabled.\n/** @type {function(*, string=)} */\nfunction assert(condition, text) {\n  if (!condition) {\n    abort('Assertion failed' + (text ? ': ' + text : ''));\n  }\n}\n\n// We used to include malloc/free by default in the past. Show a helpful error in\n// builds with assertions.\nfunction _malloc() {\n  abort('malloc() called but not included in the build - add `_malloc` to EXPORTED_FUNCTIONS');\n}\nfunction _free() {\n  // Show a helpful error since we used to include free by default in the past.\n  abort('free() called but not included in the build - add `_free` to EXPORTED_FUNCTIONS');\n}\n\n// Memory management\n\nvar HEAP, /** @type {!Int8Array} */\n  HEAP8, /** @type {!Uint8Array} */\n  HEAPU8, /** @type {!Int16Array} */\n  HEAP16, /** @type {!Uint16Array} */\n  HEAPU16, /** @type {!Int32Array} */\n  HEAP32, /** @type {!Uint32Array} */\n  HEAPU32, /** @type {!Float32Array} */\n  HEAPF32, /** @type {!Float64Array} */\n  HEAPF64;\n\n// include: runtime_shared.js\nfunction updateMemoryViews() {\n  var b = wasmMemory.buffer;\n  Module['HEAP8'] = HEAP8 = new Int8Array(b);\n  Module['HEAP16'] = HEAP16 = new Int16Array(b);\n  Module['HEAPU8'] = HEAPU8 = new Uint8Array(b);\n  Module['HEAPU16'] = HEAPU16 = new Uint16Array(b);\n  Module['HEAP32'] = HEAP32 = new Int32Array(b);\n  Module['HEAPU32'] = HEAPU32 = new Uint32Array(b);\n  Module['HEAPF32'] = HEAPF32 = new Float32Array(b);\n  Module['HEAPF64'] = HEAPF64 = new Float64Array(b);\n}\n// end include: runtime_shared.js\nassert(!Module['STACK_SIZE'], 'STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time');\nassert(typeof Int32Array != 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined, 'JS engine does not provide full typed array support');\n\n// If memory is defined in wasm, the user can't provide it, or set INITIAL_MEMORY\nassert(!Module['wasmMemory'], 'Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally');\nassert(!Module['INITIAL_MEMORY'], 'Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically');\n\n// include: runtime_stack_check.js\n// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\nfunction writeStackCookie() {\n  var max = _emscripten_stack_get_end2();\n  assert((max & 3) == 0);\n  // If the stack ends at address zero we write our cookies 4 bytes into the\n  // stack.  This prevents interference with SAFE_HEAP and ASAN which also\n  // monitor writes to address zero.\n  if (max == 0) {\n    max += 4;\n  }\n  // The stack grow downwards towards _emscripten_stack_get_end.\n  // We write cookies to the final two words in the stack and detect if they are\n  // ever overwritten.\n  HEAPU32[max >> 2] = 0x02135467;\n  HEAPU32[max + 4 >> 2] = 0x89BACDFE;\n  // Also test the global address 0 for integrity.\n  HEAPU32[0 >> 2] = 1668509029;\n}\nfunction checkStackCookie() {\n  if (ABORT) return;\n  var max = _emscripten_stack_get_end2();\n  // See writeStackCookie().\n  if (max == 0) {\n    max += 4;\n  }\n  var cookie1 = HEAPU32[max >> 2];\n  var cookie2 = HEAPU32[max + 4 >> 2];\n  if (cookie1 != 0x02135467 || cookie2 != 0x89BACDFE) {\n    abort(\"Stack overflow! Stack cookie has been overwritten at \".concat(ptrToString(max), \", expected hex dwords 0x89BACDFE and 0x2135467, but received \").concat(ptrToString(cookie2), \" \").concat(ptrToString(cookie1)));\n  }\n  // Also test the global address 0 for integrity.\n  if (HEAPU32[0 >> 2] != 0x63736d65 /* 'emsc' */) {\n    abort('Runtime error: The application has corrupted its heap memory area (address zero)!');\n  }\n}\n// end include: runtime_stack_check.js\n// include: runtime_assertions.js\n// Endianness check\n(function () {\n  var h16 = new Int16Array(1);\n  var h8 = new Int8Array(h16.buffer);\n  h16[0] = 0x6373;\n  if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)';\n})();\n\n// end include: runtime_assertions.js\nvar __ATPRERUN__ = []; // functions called before the runtime is initialized\nvar __ATINIT__ = []; // functions called during startup\nvar __ATEXIT__ = []; // functions called during shutdown\nvar __ATPOSTRUN__ = []; // functions called after the main() is called\n\nvar runtimeInitialized = false;\nfunction preRun() {\n  if (Module['preRun']) {\n    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];\n    while (Module['preRun'].length) {\n      addOnPreRun(Module['preRun'].shift());\n    }\n  }\n  callRuntimeCallbacks(__ATPRERUN__);\n}\nfunction initRuntime() {\n  assert(!runtimeInitialized);\n  runtimeInitialized = true;\n  checkStackCookie();\n  callRuntimeCallbacks(__ATINIT__);\n}\nfunction postRun() {\n  checkStackCookie();\n  if (Module['postRun']) {\n    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];\n    while (Module['postRun'].length) {\n      addOnPostRun(Module['postRun'].shift());\n    }\n  }\n  callRuntimeCallbacks(__ATPOSTRUN__);\n}\nfunction addOnPreRun(cb) {\n  __ATPRERUN__.unshift(cb);\n}\nfunction addOnInit(cb) {\n  __ATINIT__.unshift(cb);\n}\nfunction addOnExit(cb) {}\nfunction addOnPostRun(cb) {\n  __ATPOSTRUN__.unshift(cb);\n}\n\n// include: runtime_math.js\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\n\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc\n\nassert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\nassert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\nassert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\nassert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\n// end include: runtime_math.js\n// A counter of dependencies for calling run(). If we need to\n// do asynchronous work before running, increment this and\n// decrement it. Incrementing must happen in a place like\n// Module.preRun (used by emcc to add file preloading).\n// Note that you can add dependencies in preRun, even though\n// it happens right before run - run will be postponed until\n// the dependencies are met.\nvar runDependencies = 0;\nvar runDependencyWatcher = null;\nvar dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\nvar runDependencyTracking = {};\nfunction getUniqueRunDependency(id) {\n  var orig = id;\n  while (1) {\n    if (!runDependencyTracking[id]) return id;\n    id = orig + Math.random();\n  }\n}\nfunction addRunDependency(id) {\n  var _Module$monitorRunDep;\n  runDependencies++;\n  (_Module$monitorRunDep = Module['monitorRunDependencies']) === null || _Module$monitorRunDep === void 0 || _Module$monitorRunDep.call(Module, runDependencies);\n  if (id) {\n    assert(!runDependencyTracking[id]);\n    runDependencyTracking[id] = 1;\n    if (runDependencyWatcher === null && typeof setInterval != 'undefined') {\n      // Check for missing dependencies every few seconds\n      runDependencyWatcher = setInterval(function () {\n        if (ABORT) {\n          clearInterval(runDependencyWatcher);\n          runDependencyWatcher = null;\n          return;\n        }\n        var shown = false;\n        for (var dep in runDependencyTracking) {\n          if (!shown) {\n            shown = true;\n            err('still waiting on run dependencies:');\n          }\n          err(\"dependency: \".concat(dep));\n        }\n        if (shown) {\n          err('(end of list)');\n        }\n      }, 10000);\n    }\n  } else {\n    err('warning: run dependency added without ID');\n  }\n}\nfunction removeRunDependency(id) {\n  var _Module$monitorRunDep2;\n  runDependencies--;\n  (_Module$monitorRunDep2 = Module['monitorRunDependencies']) === null || _Module$monitorRunDep2 === void 0 || _Module$monitorRunDep2.call(Module, runDependencies);\n  if (id) {\n    assert(runDependencyTracking[id]);\n    delete runDependencyTracking[id];\n  } else {\n    err('warning: run dependency removed without ID');\n  }\n  if (runDependencies == 0) {\n    if (runDependencyWatcher !== null) {\n      clearInterval(runDependencyWatcher);\n      runDependencyWatcher = null;\n    }\n    if (dependenciesFulfilled) {\n      var callback = dependenciesFulfilled;\n      dependenciesFulfilled = null;\n      callback(); // can add another dependenciesFulfilled\n    }\n  }\n}\n\n/** @param {string|number=} what */\nfunction abort(what) {\n  var _Module$onAbort;\n  (_Module$onAbort = Module['onAbort']) === null || _Module$onAbort === void 0 || _Module$onAbort.call(Module, what);\n  what = 'Aborted(' + what + ')';\n  // TODO(sbc): Should we remove printing and leave it up to whoever\n  // catches the exception?\n  err(what);\n  ABORT = true;\n  EXITSTATUS = 1;\n\n  // Use a wasm runtime error, because a JS error might be seen as a foreign\n  // exception, which means we'd run destructors on it. We need the error to\n  // simply make the program stop.\n  // FIXME This approach does not work in Wasm EH because it currently does not assume\n  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from\n  // a trap or not based on a hidden field within the object. So at the moment\n  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that\n  // allows this in the wasm spec.\n\n  // Suppress closure compiler warning here. Closure compiler's builtin extern\n  // definition for WebAssembly.RuntimeError claims it takes no arguments even\n  // though it can.\n  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.\n  /** @suppress {checkTypes} */\n  var e = new WebAssembly.RuntimeError(what);\n\n  // Throw the error whether or not MODULARIZE is set because abort is used\n  // in code paths apart from instantiation where an exception is expected\n  // to be thrown when abort is called.\n  throw e;\n}\n\n// include: memoryprofiler.js\n// end include: memoryprofiler.js\n// show errors on likely calls to FS when it was not included\nvar FS = {\n  error: function error() {\n    abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with -sFORCE_FILESYSTEM');\n  },\n  init: function init() {\n    FS.error();\n  },\n  createDataFile: function createDataFile() {\n    FS.error();\n  },\n  createPreloadedFile: function createPreloadedFile() {\n    FS.error();\n  },\n  createLazyFile: function createLazyFile() {\n    FS.error();\n  },\n  open: function open() {\n    FS.error();\n  },\n  mkdev: function mkdev() {\n    FS.error();\n  },\n  registerDevice: function registerDevice() {\n    FS.error();\n  },\n  analyzePath: function analyzePath() {\n    FS.error();\n  },\n  ErrnoError: function ErrnoError() {\n    FS.error();\n  }\n};\nModule['FS_createDataFile'] = FS.createDataFile;\nModule['FS_createPreloadedFile'] = FS.createPreloadedFile;\n\n// include: URIUtils.js\n// Prefix of data URIs emitted by SINGLE_FILE and related options.\nvar dataURIPrefix = 'data:application/octet-stream;base64,';\n\n/**\n * Indicates whether filename is a base64 data URI.\n * @noinline\n */\nvar isDataURI = function isDataURI(filename) {\n  return filename.startsWith(dataURIPrefix);\n};\n\n/**\n * Indicates whether filename is delivered via file protocol (as opposed to http/https)\n * @noinline\n */\nvar isFileURI = function isFileURI(filename) {\n  return filename.startsWith('file://');\n};\n// end include: URIUtils.js\nfunction createExportWrapper(name, nargs) {\n  return function () {\n    assert(runtimeInitialized, \"native function `\".concat(name, \"` called before runtime initialization\"));\n    var f = wasmExports[name];\n    assert(f, \"exported native function `\".concat(name, \"` not found\"));\n    // Only assert for too many arguments. Too few can be valid since the missing arguments will be zero filled.\n    assert(arguments.length <= nargs, \"native function `\".concat(name, \"` called with \").concat(arguments.length, \" args but expects \").concat(nargs));\n    return f.apply(void 0, arguments);\n  };\n}\n\n// include: runtime_exceptions.js\n// end include: runtime_exceptions.js\nfunction findWasmBinary() {\n  var f = 'add.wasm';\n  if (!isDataURI(f)) {\n    return locateFile(f);\n  }\n  return f;\n}\nvar wasmBinaryFile;\nfunction getBinarySync(file) {\n  if (file == wasmBinaryFile && wasmBinary) {\n    return new Uint8Array(wasmBinary);\n  }\n  if (readBinary) {\n    return readBinary(file);\n  }\n  throw 'both async and sync fetching of the wasm failed';\n}\nfunction getBinaryPromise(binaryFile) {\n  // If we don't have the binary yet, load it asynchronously using readAsync.\n  if (!wasmBinary) {\n    // Fetch the binary using readAsync\n    return readAsync(binaryFile).then(function (response) {\n      return new Uint8Array( /** @type{!ArrayBuffer} */response);\n    },\n    // Fall back to getBinarySync if readAsync fails\n    function () {\n      return getBinarySync(binaryFile);\n    });\n  }\n\n  // Otherwise, getBinarySync should be able to get it synchronously\n  return Promise.resolve().then(function () {\n    return getBinarySync(binaryFile);\n  });\n}\nfunction instantiateArrayBuffer(binaryFile, imports, receiver) {\n  return getBinaryPromise(binaryFile).then(function (binary) {\n    return WebAssembly.instantiate(binary, imports);\n  }).then(receiver, function (reason) {\n    err(\"failed to asynchronously prepare wasm: \".concat(reason));\n\n    // Warn on some common problems.\n    if (isFileURI(wasmBinaryFile)) {\n      err(\"warning: Loading from a file URI (\".concat(wasmBinaryFile, \") is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing\"));\n    }\n    abort(reason);\n  });\n}\nfunction instantiateAsync(binary, binaryFile, imports, callback) {\n  if (!binary && typeof WebAssembly.instantiateStreaming == 'function' && !isDataURI(binaryFile) &&\n  // Don't use streaming for file:// delivered objects in a webview, fetch them synchronously.\n  !isFileURI(binaryFile) &&\n  // Avoid instantiateStreaming() on Node.js environment for now, as while\n  // Node.js v18.1.0 implements it, it does not have a full fetch()\n  // implementation yet.\n  //\n  // Reference:\n  //   https://github.com/emscripten-core/emscripten/pull/16917\n  !ENVIRONMENT_IS_NODE && typeof fetch == 'function') {\n    return fetch(binaryFile, {\n      credentials: 'same-origin'\n    }).then(function (response) {\n      // Suppress closure warning here since the upstream definition for\n      // instantiateStreaming only allows Promise<Repsponse> rather than\n      // an actual Response.\n      // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.\n      /** @suppress {checkTypes} */\n      var result = WebAssembly.instantiateStreaming(response, imports);\n      return result.then(callback, function (reason) {\n        // We expect the most common failure cause to be a bad MIME type for the binary,\n        // in which case falling back to ArrayBuffer instantiation should work.\n        err(\"wasm streaming compile failed: \".concat(reason));\n        err('falling back to ArrayBuffer instantiation');\n        return instantiateArrayBuffer(binaryFile, imports, callback);\n      });\n    });\n  }\n  return instantiateArrayBuffer(binaryFile, imports, callback);\n}\nfunction getWasmImports() {\n  // prepare imports\n  return {\n    'env': wasmImports,\n    'wasi_snapshot_preview1': wasmImports\n  };\n}\n\n// Create the wasm instance.\n// Receives the wasm imports, returns the exports.\nfunction createWasm() {\n  var info = getWasmImports();\n  // Load the wasm module and create an instance of using native support in the JS engine.\n  // handle a generated wasm instance, receiving its exports and\n  // performing other necessary setup\n  /** @param {WebAssembly.Module=} module*/\n  function receiveInstance(instance, module) {\n    wasmExports = instance.exports;\n    wasmMemory = wasmExports['memory'];\n    assert(wasmMemory, 'memory not found in wasm exports');\n    updateMemoryViews();\n    addOnInit(wasmExports['__wasm_call_ctors']);\n    removeRunDependency('wasm-instantiate');\n    return wasmExports;\n  }\n  // wait for the pthread pool (if any)\n  addRunDependency('wasm-instantiate');\n\n  // Prefer streaming instantiation if available.\n  // Async compilation can be confusing when an error on the page overwrites Module\n  // (for example, if the order of elements is wrong, and the one defining Module is\n  // later), so we save Module and check it later.\n  var trueModule = Module;\n  function receiveInstantiationResult(result) {\n    // 'result' is a ResultObject object which has both the module and instance.\n    // receiveInstance() will swap in the exports (to Module.asm) so they can be called\n    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');\n    trueModule = null;\n    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\n    // When the regression is fixed, can restore the above PTHREADS-enabled path.\n    receiveInstance(result['instance']);\n  }\n\n  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\n  // to manually instantiate the Wasm module themselves. This allows pages to\n  // run the instantiation parallel to any other async startup actions they are\n  // performing.\n  // Also pthreads and wasm workers initialize the wasm instance through this\n  // path.\n  if (Module['instantiateWasm']) {\n    try {\n      return Module['instantiateWasm'](info, receiveInstance);\n    } catch (e) {\n      err(\"Module.instantiateWasm callback failed with error: \".concat(e));\n      return false;\n    }\n  }\n  if (!wasmBinaryFile) wasmBinaryFile = findWasmBinary();\n  instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult);\n  return {}; // no exports yet; we'll fill them in later\n}\n\n// Globals used by JS i64 conversions (see makeSetValue)\nvar tempDouble;\nvar tempI64;\n\n// include: runtime_debug.js\nfunction legacyModuleProp(prop, newName) {\n  var incoming = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  if (!Object.getOwnPropertyDescriptor(Module, prop)) {\n    Object.defineProperty(Module, prop, {\n      configurable: true,\n      get: function get() {\n        var extra = incoming ? ' (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)' : '';\n        abort(\"`Module.\".concat(prop, \"` has been replaced by `\").concat(newName, \"`\") + extra);\n      }\n    });\n  }\n}\nfunction ignoredModuleProp(prop) {\n  if (Object.getOwnPropertyDescriptor(Module, prop)) {\n    abort(\"`Module.\".concat(prop, \"` was supplied but `\").concat(prop, \"` not included in INCOMING_MODULE_JS_API\"));\n  }\n}\n\n// forcing the filesystem exports a few things by default\nfunction isExportedByForceFilesystem(name) {\n  return name === 'FS_createPath' || name === 'FS_createDataFile' || name === 'FS_createPreloadedFile' || name === 'FS_unlink' || name === 'addRunDependency' ||\n  // The old FS has some functionality that WasmFS lacks.\n  name === 'FS_createLazyFile' || name === 'FS_createDevice' || name === 'removeRunDependency';\n}\nfunction missingGlobal(sym, msg) {\n  if (typeof globalThis != 'undefined') {\n    Object.defineProperty(globalThis, sym, {\n      configurable: true,\n      get: function get() {\n        warnOnce(\"`\".concat(sym, \"` is not longer defined by emscripten. \").concat(msg));\n        return undefined;\n      }\n    });\n  }\n}\nmissingGlobal('buffer', 'Please use HEAP8.buffer or wasmMemory.buffer');\nmissingGlobal('asm', 'Please use wasmExports instead');\nfunction missingLibrarySymbol(sym) {\n  if (typeof globalThis != 'undefined' && !Object.getOwnPropertyDescriptor(globalThis, sym)) {\n    Object.defineProperty(globalThis, sym, {\n      configurable: true,\n      get: function get() {\n        // Can't `abort()` here because it would break code that does runtime\n        // checks.  e.g. `if (typeof SDL === 'undefined')`.\n        var msg = \"`\".concat(sym, \"` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line\");\n        // DEFAULT_LIBRARY_FUNCS_TO_INCLUDE requires the name as it appears in\n        // library.js, which means $name for a JS name with no prefix, or name\n        // for a JS name like _name.\n        var librarySymbol = sym;\n        if (!librarySymbol.startsWith('_')) {\n          librarySymbol = '$' + sym;\n        }\n        msg += \" (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='\".concat(librarySymbol, \"')\");\n        if (isExportedByForceFilesystem(sym)) {\n          msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';\n        }\n        warnOnce(msg);\n        return undefined;\n      }\n    });\n  }\n  // Any symbol that is not included from the JS library is also (by definition)\n  // not exported on the Module object.\n  unexportedRuntimeSymbol(sym);\n}\nfunction unexportedRuntimeSymbol(sym) {\n  if (!Object.getOwnPropertyDescriptor(Module, sym)) {\n    Object.defineProperty(Module, sym, {\n      configurable: true,\n      get: function get() {\n        var msg = \"'\".concat(sym, \"' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)\");\n        if (isExportedByForceFilesystem(sym)) {\n          msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';\n        }\n        abort(msg);\n      }\n    });\n  }\n}\n\n// Used by XXXXX_DEBUG settings to output debug messages.\nfunction dbg() {\n  var _console;\n  // TODO(sbc): Make this configurable somehow.  Its not always convenient for\n  // logging to show up as warnings.\n  (_console = console).warn.apply(_console, arguments);\n}\n// end include: runtime_debug.js\n// === Body ===\n// end include: preamble.js\n\n/** @constructor */\nfunction ExitStatus(status) {\n  this.name = 'ExitStatus';\n  this.message = \"Program terminated with exit(\".concat(status, \")\");\n  this.status = status;\n}\nvar callRuntimeCallbacks = function callRuntimeCallbacks(callbacks) {\n  while (callbacks.length > 0) {\n    // Pass the module as the first argument.\n    callbacks.shift()(Module);\n  }\n};\n\n/**\n * @param {number} ptr\n * @param {string} type\n */\nfunction getValue(ptr) {\n  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'i8';\n  if (type.endsWith('*')) type = '*';\n  switch (type) {\n    case 'i1':\n      return HEAP8[ptr];\n    case 'i8':\n      return HEAP8[ptr];\n    case 'i16':\n      return HEAP16[ptr >> 1];\n    case 'i32':\n      return HEAP32[ptr >> 2];\n    case 'i64':\n      abort('to do getValue(i64) use WASM_BIGINT');\n    case 'float':\n      return HEAPF32[ptr >> 2];\n    case 'double':\n      return HEAPF64[ptr >> 3];\n    case '*':\n      return HEAPU32[ptr >> 2];\n    default:\n      abort(\"invalid type for getValue: \".concat(type));\n  }\n}\nvar noExitRuntime = Module['noExitRuntime'] || true;\nvar ptrToString = function ptrToString(ptr) {\n  assert(typeof ptr === 'number');\n  // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\n  ptr >>>= 0;\n  return '0x' + ptr.toString(16).padStart(8, '0');\n};\n\n/**\n * @param {number} ptr\n * @param {number} value\n * @param {string} type\n */\nfunction setValue(ptr, value) {\n  var type = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'i8';\n  if (type.endsWith('*')) type = '*';\n  switch (type) {\n    case 'i1':\n      HEAP8[ptr] = value;\n      break;\n    case 'i8':\n      HEAP8[ptr] = value;\n      break;\n    case 'i16':\n      HEAP16[ptr >> 1] = value;\n      break;\n    case 'i32':\n      HEAP32[ptr >> 2] = value;\n      break;\n    case 'i64':\n      abort('to do setValue(i64) use WASM_BIGINT');\n    case 'float':\n      HEAPF32[ptr >> 2] = value;\n      break;\n    case 'double':\n      HEAPF64[ptr >> 3] = value;\n      break;\n    case '*':\n      HEAPU32[ptr >> 2] = value;\n      break;\n    default:\n      abort(\"invalid type for setValue: \".concat(type));\n  }\n}\nvar stackRestore = function stackRestore(val) {\n  return _emscripten_stack_restore(val);\n};\nvar stackSave = function stackSave() {\n  return _emscripten_stack_get_current2();\n};\nvar warnOnce = function warnOnce(text) {\n  warnOnce.shown || (warnOnce.shown = {});\n  if (!warnOnce.shown[text]) {\n    warnOnce.shown[text] = 1;\n    if (ENVIRONMENT_IS_NODE) text = 'warning: ' + text;\n    err(text);\n  }\n};\nvar getCFunc = function getCFunc(ident) {\n  var func = Module['_' + ident]; // closure exported function\n  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');\n  return func;\n};\nvar writeArrayToMemory = function writeArrayToMemory(array, buffer) {\n  assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)');\n  HEAP8.set(array, buffer);\n};\nvar lengthBytesUTF8 = function lengthBytesUTF8(str) {\n  var len = 0;\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\n    // unit, not a Unicode code point of the character! So decode\n    // UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    var c = str.charCodeAt(i); // possibly a lead surrogate\n    if (c <= 0x7F) {\n      len++;\n    } else if (c <= 0x7FF) {\n      len += 2;\n    } else if (c >= 0xD800 && c <= 0xDFFF) {\n      len += 4;\n      ++i;\n    } else {\n      len += 3;\n    }\n  }\n  return len;\n};\nvar stringToUTF8Array = function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {\n  assert(typeof str === 'string', \"stringToUTF8Array expects a string (got \".concat(_typeof(str), \")\"));\n  // Parameter maxBytesToWrite is not optional. Negative values, 0, null,\n  // undefined and false each don't write out any bytes.\n  if (!(maxBytesToWrite > 0)) return 0;\n  var startIdx = outIdx;\n  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\n  for (var i = 0; i < str.length; ++i) {\n    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\n    // unit, not a Unicode code point of the character! So decode\n    // UTF16->UTF32->UTF8.\n    // See http://unicode.org/faq/utf_bom.html#utf16-3\n    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description\n    // and https://www.ietf.org/rfc/rfc2279.txt\n    // and https://tools.ietf.org/html/rfc3629\n    var u = str.charCodeAt(i); // possibly a lead surrogate\n    if (u >= 0xD800 && u <= 0xDFFF) {\n      var u1 = str.charCodeAt(++i);\n      u = 0x10000 + ((u & 0x3FF) << 10) | u1 & 0x3FF;\n    }\n    if (u <= 0x7F) {\n      if (outIdx >= endIdx) break;\n      heap[outIdx++] = u;\n    } else if (u <= 0x7FF) {\n      if (outIdx + 1 >= endIdx) break;\n      heap[outIdx++] = 0xC0 | u >> 6;\n      heap[outIdx++] = 0x80 | u & 63;\n    } else if (u <= 0xFFFF) {\n      if (outIdx + 2 >= endIdx) break;\n      heap[outIdx++] = 0xE0 | u >> 12;\n      heap[outIdx++] = 0x80 | u >> 6 & 63;\n      heap[outIdx++] = 0x80 | u & 63;\n    } else {\n      if (outIdx + 3 >= endIdx) break;\n      if (u > 0x10FFFF) warnOnce('Invalid Unicode code point ' + ptrToString(u) + ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).');\n      heap[outIdx++] = 0xF0 | u >> 18;\n      heap[outIdx++] = 0x80 | u >> 12 & 63;\n      heap[outIdx++] = 0x80 | u >> 6 & 63;\n      heap[outIdx++] = 0x80 | u & 63;\n    }\n  }\n  // Null-terminate the pointer to the buffer.\n  heap[outIdx] = 0;\n  return outIdx - startIdx;\n};\nvar stringToUTF8 = function stringToUTF8(str, outPtr, maxBytesToWrite) {\n  assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\n  return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\n};\nvar stackAlloc = function stackAlloc(sz) {\n  return _emscripten_stack_alloc(sz);\n};\nvar stringToUTF8OnStack = function stringToUTF8OnStack(str) {\n  var size = lengthBytesUTF8(str) + 1;\n  var ret = stackAlloc(size);\n  stringToUTF8(str, ret, size);\n  return ret;\n};\nvar UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder() : undefined;\n\n/**\n * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given\n * array that contains uint8 values, returns a copy of that string as a\n * Javascript String object.\n * heapOrArray is either a regular array, or a JavaScript typed array view.\n * @param {number} idx\n * @param {number=} maxBytesToRead\n * @return {string}\n */\nvar UTF8ArrayToString = function UTF8ArrayToString(heapOrArray, idx, maxBytesToRead) {\n  var endIdx = idx + maxBytesToRead;\n  var endPtr = idx;\n  // TextDecoder needs to know the byte length in advance, it doesn't stop on\n  // null terminator by itself.  Also, use the length info to avoid running tiny\n  // strings through TextDecoder, since .subarray() allocates garbage.\n  // (As a tiny code save trick, compare endPtr against endIdx using a negation,\n  // so that undefined means Infinity)\n  while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\n  if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\n    return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\n  }\n  var str = '';\n  // If building with TextDecoder, we have already computed the string length\n  // above, so test loop end condition against that\n  while (idx < endPtr) {\n    // For UTF8 byte structure, see:\n    // http://en.wikipedia.org/wiki/UTF-8#Description\n    // https://www.ietf.org/rfc/rfc2279.txt\n    // https://tools.ietf.org/html/rfc3629\n    var u0 = heapOrArray[idx++];\n    if (!(u0 & 0x80)) {\n      str += String.fromCharCode(u0);\n      continue;\n    }\n    var u1 = heapOrArray[idx++] & 63;\n    if ((u0 & 0xE0) == 0xC0) {\n      str += String.fromCharCode((u0 & 31) << 6 | u1);\n      continue;\n    }\n    var u2 = heapOrArray[idx++] & 63;\n    if ((u0 & 0xF0) == 0xE0) {\n      u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n    } else {\n      if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte ' + ptrToString(u0) + ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!');\n      u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;\n    }\n    if (u0 < 0x10000) {\n      str += String.fromCharCode(u0);\n    } else {\n      var ch = u0 - 0x10000;\n      str += String.fromCharCode(0xD800 | ch >> 10, 0xDC00 | ch & 0x3FF);\n    }\n  }\n  return str;\n};\n\n/**\n * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the\n * emscripten HEAP, returns a copy of that string as a Javascript String object.\n *\n * @param {number} ptr\n * @param {number=} maxBytesToRead - An optional length that specifies the\n *   maximum number of bytes to read. You can omit this parameter to scan the\n *   string until the first 0 byte. If maxBytesToRead is passed, and the string\n *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the\n *   string will cut short at that byte index (i.e. maxBytesToRead will not\n *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing\n *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw\n *   JS JIT optimizations off, so it is worth to consider consistently using one\n * @return {string}\n */\nvar UTF8ToString = function UTF8ToString(ptr, maxBytesToRead) {\n  assert(typeof ptr == 'number', \"UTF8ToString expects a number (got \".concat(_typeof(ptr), \")\"));\n  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\n};\n\n/**\n * @param {string|null=} returnType\n * @param {Array=} argTypes\n * @param {Arguments|Array=} args\n * @param {Object=} opts\n */\nvar ccall = function ccall(ident, returnType, argTypes, args, opts) {\n  // For fast lookup of conversion functions\n  var toC = {\n    'string': function string(str) {\n      var ret = 0;\n      if (str !== null && str !== undefined && str !== 0) {\n        // null string\n        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\\0'\n        ret = stringToUTF8OnStack(str);\n      }\n      return ret;\n    },\n    'array': function array(arr) {\n      var ret = stackAlloc(arr.length);\n      writeArrayToMemory(arr, ret);\n      return ret;\n    }\n  };\n  function convertReturnValue(ret) {\n    if (returnType === 'string') {\n      return UTF8ToString(ret);\n    }\n    if (returnType === 'boolean') return Boolean(ret);\n    return ret;\n  }\n  var func = getCFunc(ident);\n  var cArgs = [];\n  var stack = 0;\n  assert(returnType !== 'array', 'Return type should not be \"array\".');\n  if (args) {\n    for (var i = 0; i < args.length; i++) {\n      var converter = toC[argTypes[i]];\n      if (converter) {\n        if (stack === 0) stack = stackSave();\n        cArgs[i] = converter(args[i]);\n      } else {\n        cArgs[i] = args[i];\n      }\n    }\n  }\n  var ret = func.apply(void 0, cArgs);\n  function onDone(ret) {\n    if (stack !== 0) stackRestore(stack);\n    return convertReturnValue(ret);\n  }\n  ret = onDone(ret);\n  return ret;\n};\n\n/**\n * @param {string=} returnType\n * @param {Array=} argTypes\n * @param {Object=} opts\n */\nvar cwrap = function cwrap(ident, returnType, argTypes, opts) {\n  return function () {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n    return ccall(ident, returnType, argTypes, args, opts);\n  };\n};\nfunction checkIncomingModuleAPI() {\n  ignoredModuleProp('fetchSettings');\n}\nvar wasmImports = {};\nvar wasmExports = createWasm();\nvar ___wasm_call_ctors = createExportWrapper('__wasm_call_ctors', 0);\nvar _add = Module['_add'] = createExportWrapper('add', 2);\nvar _fflush = createExportWrapper('fflush', 1);\nvar _emscripten_stack_init2 = function _emscripten_stack_init() {\n  return (_emscripten_stack_init2 = wasmExports['emscripten_stack_init'])();\n};\nvar _emscripten_stack_get_free2 = function _emscripten_stack_get_free() {\n  return (_emscripten_stack_get_free2 = wasmExports['emscripten_stack_get_free'])();\n};\nvar _emscripten_stack_get_base2 = function _emscripten_stack_get_base() {\n  return (_emscripten_stack_get_base2 = wasmExports['emscripten_stack_get_base'])();\n};\nvar _emscripten_stack_get_end2 = function _emscripten_stack_get_end() {\n  return (_emscripten_stack_get_end2 = wasmExports['emscripten_stack_get_end'])();\n};\nvar _emscripten_stack_restore = function __emscripten_stack_restore(a0) {\n  return (_emscripten_stack_restore = wasmExports['_emscripten_stack_restore'])(a0);\n};\nvar _emscripten_stack_alloc = function __emscripten_stack_alloc(a0) {\n  return (_emscripten_stack_alloc = wasmExports['_emscripten_stack_alloc'])(a0);\n};\nvar _emscripten_stack_get_current2 = function _emscripten_stack_get_current() {\n  return (_emscripten_stack_get_current2 = wasmExports['emscripten_stack_get_current'])();\n};\n\n// include: postamble.js\n// === Auto-generated postamble setup entry stuff ===\n\nModule['cwrap'] = cwrap;\nvar missingLibrarySymbols = ['writeI53ToI64', 'writeI53ToI64Clamped', 'writeI53ToI64Signaling', 'writeI53ToU64Clamped', 'writeI53ToU64Signaling', 'readI53FromI64', 'readI53FromU64', 'convertI32PairToI53', 'convertI32PairToI53Checked', 'convertU32PairToI53', 'getTempRet0', 'setTempRet0', 'zeroMemory', 'exitJS', 'getHeapMax', 'abortOnCannotGrowMemory', 'growMemory', 'isLeapYear', 'ydayFromDate', 'arraySum', 'addDays', 'strError', 'inetPton4', 'inetNtop4', 'inetPton6', 'inetNtop6', 'readSockaddr', 'writeSockaddr', 'initRandomFill', 'randomFill', 'emscriptenLog', 'readEmAsmArgs', 'jstoi_q', 'getExecutableName', 'listenOnce', 'autoResumeAudioContext', 'dynCallLegacy', 'getDynCaller', 'dynCall', 'handleException', 'keepRuntimeAlive', 'runtimeKeepalivePush', 'runtimeKeepalivePop', 'callUserCallback', 'maybeExit', 'asmjsMangle', 'asyncLoad', 'alignMemory', 'mmapAlloc', 'HandleAllocator', 'getNativeTypeSize', 'STACK_SIZE', 'STACK_ALIGN', 'POINTER_SIZE', 'ASSERTIONS', 'uleb128Encode', 'sigToWasmTypes', 'generateFuncType', 'convertJsFunctionToWasm', 'getEmptyTableSlot', 'updateTableMap', 'getFunctionAddress', 'addFunction', 'removeFunction', 'reallyNegative', 'unSign', 'strLen', 'reSign', 'formatString', 'intArrayFromString', 'intArrayToString', 'AsciiToString', 'stringToAscii', 'UTF16ToString', 'stringToUTF16', 'lengthBytesUTF16', 'UTF32ToString', 'stringToUTF32', 'lengthBytesUTF32', 'stringToNewUTF8', 'registerKeyEventCallback', 'maybeCStringToJsString', 'findEventTarget', 'getBoundingClientRect', 'fillMouseEventData', 'registerMouseEventCallback', 'registerWheelEventCallback', 'registerUiEventCallback', 'registerFocusEventCallback', 'fillDeviceOrientationEventData', 'registerDeviceOrientationEventCallback', 'fillDeviceMotionEventData', 'registerDeviceMotionEventCallback', 'screenOrientation', 'fillOrientationChangeEventData', 'registerOrientationChangeEventCallback', 'fillFullscreenChangeEventData', 'registerFullscreenChangeEventCallback', 'JSEvents_requestFullscreen', 'JSEvents_resizeCanvasForFullscreen', 'registerRestoreOldStyle', 'hideEverythingExceptGivenElement', 'restoreHiddenElements', 'setLetterbox', 'softFullscreenResizeWebGLRenderTarget', 'doRequestFullscreen', 'fillPointerlockChangeEventData', 'registerPointerlockChangeEventCallback', 'registerPointerlockErrorEventCallback', 'requestPointerLock', 'fillVisibilityChangeEventData', 'registerVisibilityChangeEventCallback', 'registerTouchEventCallback', 'fillGamepadEventData', 'registerGamepadEventCallback', 'registerBeforeUnloadEventCallback', 'fillBatteryEventData', 'battery', 'registerBatteryEventCallback', 'setCanvasElementSize', 'getCanvasElementSize', 'jsStackTrace', 'getCallstack', 'convertPCtoSourceLocation', 'getEnvStrings', 'checkWasiClock', 'flush_NO_FILESYSTEM', 'wasiRightsToMuslOFlags', 'wasiOFlagsToMuslOFlags', 'createDyncallWrapper', 'safeSetTimeout', 'setImmediateWrapped', 'clearImmediateWrapped', 'polyfillSetImmediate', 'getPromise', 'makePromise', 'idsToPromises', 'makePromiseCallback', 'ExceptionInfo', 'findMatchingCatch', 'Browser_asyncPrepareDataCounter', 'setMainLoop', 'getSocketFromFD', 'getSocketAddress', 'FS_createPreloadedFile', 'FS_modeStringToFlags', 'FS_getMode', 'FS_stdin_getChar', 'FS_unlink', 'FS_createDataFile', 'FS_mkdirTree', '_setNetworkCallback', 'heapObjectForWebGLType', 'toTypedArrayIndex', 'webgl_enable_ANGLE_instanced_arrays', 'webgl_enable_OES_vertex_array_object', 'webgl_enable_WEBGL_draw_buffers', 'webgl_enable_WEBGL_multi_draw', 'emscriptenWebGLGet', 'computeUnpackAlignedImageSize', 'colorChannelsInGlTextureFormat', 'emscriptenWebGLGetTexPixelData', 'emscriptenWebGLGetUniform', 'webglGetUniformLocation', 'webglPrepareUniformLocationsBeforeFirstUse', 'webglGetLeftBracePos', 'emscriptenWebGLGetVertexAttrib', '__glGetActiveAttribOrUniform', 'writeGLArray', 'registerWebGlEventCallback', 'runAndAbortIfError', 'ALLOC_NORMAL', 'ALLOC_STACK', 'allocate', 'writeStringToMemory', 'writeAsciiToMemory', 'setErrNo', 'demangle', 'stackTrace'];\nmissingLibrarySymbols.forEach(missingLibrarySymbol);\nvar unexportedSymbols = ['run', 'addOnPreRun', 'addOnInit', 'addOnPreMain', 'addOnExit', 'addOnPostRun', 'addRunDependency', 'removeRunDependency', 'out', 'err', 'callMain', 'abort', 'wasmMemory', 'wasmExports', 'writeStackCookie', 'checkStackCookie', 'stackSave', 'stackRestore', 'stackAlloc', 'ptrToString', 'ENV', 'MONTH_DAYS_REGULAR', 'MONTH_DAYS_LEAP', 'MONTH_DAYS_REGULAR_CUMULATIVE', 'MONTH_DAYS_LEAP_CUMULATIVE', 'ERRNO_CODES', 'DNS', 'Protocols', 'Sockets', 'timers', 'warnOnce', 'readEmAsmArgsArray', 'jstoi_s', 'wasmTable', 'noExitRuntime', 'getCFunc', 'ccall', 'freeTableIndexes', 'functionsInTableMap', 'setValue', 'getValue', 'PATH', 'PATH_FS', 'UTF8Decoder', 'UTF8ArrayToString', 'UTF8ToString', 'stringToUTF8Array', 'stringToUTF8', 'lengthBytesUTF8', 'UTF16Decoder', 'stringToUTF8OnStack', 'writeArrayToMemory', 'JSEvents', 'specialHTMLTargets', 'findCanvasEventTarget', 'currentFullscreenStrategy', 'restoreOldWindowedStyle', 'UNWIND_CACHE', 'ExitStatus', 'promiseMap', 'uncaughtExceptionCount', 'exceptionLast', 'exceptionCaught', 'Browser', 'getPreloadedImageData__data', 'wget', 'SYSCALLS', 'preloadPlugins', 'FS_stdin_getChar_buffer', 'FS_createPath', 'FS_createDevice', 'FS_readFile', 'FS', 'FS_createLazyFile', 'MEMFS', 'TTY', 'PIPEFS', 'SOCKFS', 'tempFixedLengthArray', 'miniTempWebGLFloatBuffers', 'miniTempWebGLIntBuffers', 'GL', 'AL', 'GLUT', 'EGL', 'GLEW', 'IDBStore', 'SDL', 'SDL_gfx', 'allocateUTF8', 'allocateUTF8OnStack', 'print', 'printErr'];\nunexportedSymbols.forEach(unexportedRuntimeSymbol);\nvar calledRun;\ndependenciesFulfilled = function runCaller() {\n  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\n  if (!calledRun) run();\n  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\n};\nfunction stackCheckInit() {\n  // This is normally called automatically during __wasm_call_ctors but need to\n  // get these values before even running any of the ctors so we call it redundantly\n  // here.\n  _emscripten_stack_init2();\n  // TODO(sbc): Move writeStackCookie to native to to avoid this.\n  writeStackCookie();\n}\nfunction run() {\n  if (runDependencies > 0) {\n    return;\n  }\n  stackCheckInit();\n  preRun();\n\n  // a preRun added a dependency, run will be called later\n  if (runDependencies > 0) {\n    return;\n  }\n  function doRun() {\n    var _Module$onRuntimeInit;\n    // run may have just been called through dependencies being fulfilled just in this very frame,\n    // or while the async setStatus time below was happening\n    if (calledRun) return;\n    calledRun = true;\n    Module['calledRun'] = true;\n    if (ABORT) return;\n    initRuntime();\n    (_Module$onRuntimeInit = Module['onRuntimeInitialized']) === null || _Module$onRuntimeInit === void 0 || _Module$onRuntimeInit.call(Module);\n    assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');\n    postRun();\n  }\n  if (Module['setStatus']) {\n    Module['setStatus']('Running...');\n    setTimeout(function () {\n      setTimeout(function () {\n        Module['setStatus']('');\n      }, 1);\n      doRun();\n    }, 1);\n  } else {\n    doRun();\n  }\n  checkStackCookie();\n}\nfunction checkUnflushedContent() {\n  // Compiler settings do not allow exiting the runtime, so flushing\n  // the streams is not possible. but in ASSERTIONS mode we check\n  // if there was something to flush, and if so tell the user they\n  // should request that the runtime be exitable.\n  // Normally we would not even include flush() at all, but in ASSERTIONS\n  // builds we do so just for this check, and here we see if there is any\n  // content to flush, that is, we check if there would have been\n  // something a non-ASSERTIONS build would have not seen.\n  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0\n  // mode (which has its own special function for this; otherwise, all\n  // the code is inside libc)\n  var oldOut = out;\n  var oldErr = err;\n  var has = false;\n  out = err = function err(x) {\n    has = true;\n  };\n  try {\n    // it doesn't matter if it fails\n    _fflush(0);\n  } catch (e) {}\n  out = oldOut;\n  err = oldErr;\n  if (has) {\n    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc.');\n    warnOnce('(this may also be due to not including full filesystem support - try building with -sFORCE_FILESYSTEM)');\n  }\n}\nif (Module['preInit']) {\n  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\n  while (Module['preInit'].length > 0) {\n    Module['preInit'].pop()();\n  }\n}\nrun();\n\n// end include: postamble.js\n\n//# sourceURL=webpack://mapapp/./pj/static/C++/add.js?");

/***/ }),

/***/ "?e683":
/*!********************!*\
  !*** fs (ignored) ***!
  \********************/
/***/ (() => {

eval("/* (ignored) */\n\n//# sourceURL=webpack://mapapp/fs_(ignored)?");

/***/ })

}]);